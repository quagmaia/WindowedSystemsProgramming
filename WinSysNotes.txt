Windowed Systems Notes

--------------------
------08-24-17------
--------------------

seam graph:
	composed of nodes and subclasses of nodes
two distinct subclasses of node:
	-node -> parent -> REGION
		rectangular thing that supports being laid out and CSS styling
	-node -> parent -? GROUP
		can have any arbitrary transformation applied to it 
		good for neat custom graphics
		not easy to resize
lets say you have a window that you want to have resizable, that will move buttons and windows inside and stuff. 
	-good news: automatically recalculates size for you in most graphics kits
	-!!!!!!all homeworks will expect me to have a resizable interface!!!!!!
kits often include "v boxes" and "h boxes"--meaning, rows and columns that hold stuff
kits also have a grid type thing. it lays its area into rectilinear regions
	-elements can go into multiple cells
	-lets you control which areas should grow during resizing 
anchor points help you decide where a thing attatches and keeps its location somewhat static. depends how many achor points you add
can use grid or anchors for hw!!
checkmarks in JavaFx
	-some methods:
		getIsChecked()
		getIsCheckedProperty() -> allows binding. so if you bind the property to something else, you never have to connect them again, they just stay synched. 
	-more on binding: can also attatch events to properties this way
FXML
JavaFx applications don't need a main method. they do need the start method!

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}

lets add labels:

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Label bar = new Label("bar");
		root.add(bar,0,1);		//this one will go just below foo
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
mess with regions:

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Region r = new Region();	//supports no args on init
		root.add(r,1,1);	//below and to right of foo
		
		GridPane.setHgrow(r, Priority.ALWAYS);	//these static methods make sure that resizing
		GridPane.setVGrow(r, Priority.ALWAYS);	//works so that bar is always in bottom right
		
		Label bar = new Label("bar");
		root.add(12,2,2);
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
buttons:

	public void start(Stage primary){
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); 
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Region r = new Region();
		root.add(r,1,1);	//below and to right of foo
		
		GridPane.setHgrow(r, Priority.ALWAYS);
		GridPane.setVGrow(r, Priority.ALWAYS);
		
		Button butt = new Button("clicky");
		root.add(butt,2,2);
		butt.setOnAction(
			event -> { System.out.println("clickoo"); }	//when you click, terminal prints
		);												// you can also specify type of event
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
how to make an interface reusable:

	class BasicWidget extends GridPane {
		public BasicWidget(){
		
			Label foo = new Label("foo");
			add(foo, 0, 0);
			
			Region r = new Region();
			add(r,1,1);		//just add instead of root.add()
			
			GridPane.setHgrow(r, Priority.ALWAYS);
			GridPane.setVGrow(r, Priority.ALWAYS);
			
			Button butt = new Button("clicky");
			add(butt,2,2);
			butt.setOnAction(
				event -> { System.out.println("clickoo"); }
			);
		}
	}
	
	public void Start(Stage primary){
		primary.setTitle("window");
		BasicWidget bw = new BasicWidget(); //here's the replacement!
		primaryStage.setScene(new Scene(bw,400,400));	//bw instead of GridPane root as before
		primary.show();
	}
		
you can have multiple BasicWidgets if you want!

--------------------
------08-29-17------
--------------------

New hw to be assigned this Thrusday, and then due a week later.

Things we will cover today: checkbox, radio button, combobox
	-all these things inherit the clicked event
	-these things expose to us properties. Instead of listening for an action event, we want to use the info we would get from their interraction.
checkbox
	-we really just care about whether or not it's selected
	-three options: unchecked, checked, and " - ". 
		-some languages handle this by making it an enum type
		-JavaFx: two boolean properties: does this box allow indeterminence? Is it checked or unchecked?
		-in this class we are gonna ignore indeterminence. only checked and unchecked for now

checkbox example:

class ClassWidget extends GridPane {
	public ClassWidget(){
		CheckBox cb = new CheckBox("Check me!");
		add(cb, 0, 0);
		
		cb.setOnAction(
			(event) -> System.Out.Println("Hi"); //on check or uncheck, this goes to terminal
		);
	}
}
	
getting checkbox property:

class ClassWidget extends GridPane {
	public ClassWidget(){
		CheckBox cb = new CheckBox("Check me!");
		add(cb, 0, 0);
		
		cb.setOnAction(
			(event) -> System.Out.Println("Hi") //on check or uncheck, this goes to terminal
		);
			
		Button b = new Button("Print");
		add(b, 0, 50);		//it's okay to have a larger number for location than what's avaliable here, it works out
		b.setOnAction(
			(event) -> System.out.println(cb.selectedProperty().get())	//prints the state of the checkbox when you press the button
		);
	}
}
	
In most graphical kits, there is a concept of a control being enabled or disabled. Think of greyed out windows. 
In JavaFx, when you disable a control, the display will still be re-rendered (allowing resizing), it just can't generate events. 

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			cb.setOnAction(
				(event) -> System.Out.Println("Hi")
			);
				
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().set(true);	//note: DisableProperty is read/write, DisabledProperty is read-only
											//it's possible for them to be different. 
											//Disabled comes from its ancestors, Disable is specific to it. Shitty naming though lol
}}
	
disable events:

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
				
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().set(true);
			
			cb.setOnAction(
				(event) ->{
					if (cb.selectedProperty().get()){
						b.disableProperty().set(false);
					} else {
						b.disableProperty().set(true);
					}
				}
			);
}}
	
This setup has some annoying cross-coupling. There's a better way!

class ClassWidget extends GridPane {
public ClassWidget(){
	CheckBox cb = new CheckBox("Check me!");
	add(cb, 0, 0);
		
	Button b = new Button("Print");
	add(b, 0, 50);
	b.setOnAction(
		(event) -> System.out.println(cb.selectedProperty().get())
	);
	
	b.disableProperty().bind(Bindings.not(cb.selectedProperty()));	//system automatically connects the properties
	//Bindings class allows you to have a more specific binding. 
	//In this case it inverts, allowing b's property to be inverse to cb's property.
	//They start out in sync!!!! Binding guarentees that everything automatically updates form the start
}}

Radio buttons! Well, groups of radio buttons!
	-it's a lot like a checkbox, except that at most, only one in a given group can be checked at a time
	-some graphical kits allow you to have none selected, others will always have exactly one
	-JavaFx is fine with none selected. In this case, that is "null"

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ToggleGroup tga = new ToggleGroup();	//only one in a group can be selected
				
			RadioButton ra1 = new RadioButton("ra1");
			add(ra1, 0, 1);
			ra1.setToggleGroup(tga);	//ToggleGroup not exposed as a property, becuase that implies 
										//you'd want to change the grouping later, which is dumb
			
			RadioButton ra2 = new RadioButton("ra2");
			add(ra1, 0, 2);
			ra2.setToggleGroup(tga);
			
			RadioButton ra3 = new RadioButton("ra3");
			add(ra1, 1, 1);
			ra3.setToggleGroup(tga);
			
			tga.selectedToggleProperty().addListener(
				(observable, old_val, new_val) -> {
					System.out.println("changed");	//button selection prints this
				}
			);
				
}}

Above prints when there's a change! But what we would really like to know is which one is selected! So.

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ToggleGroup tga = new ToggleGroup();
				
			RadioButton ra1 = new RadioButton("ra1");
			add(ra1, 0, 1);
			ra1.setToggleGroup(tga);
			
			RadioButton ra2 = new RadioButton("ra2");
			add(ra1, 0, 2);
			ra2.setToggleGroup(tga);
			
			tga.selectedToggleProperty().addListener(
				(observable, old_val, new_val) -> {		//old_val and new_val are the actual RadioButtons
					if (new_val == ra1){
						System.out.println("ra1");
					} else if (new_val == ra2){
						System.out.println("ra2");
					}
				}
			);
				
}}

combo box!!! It's like a dropdown box, but a user can also type in their own new input.
	-used to be that comboboxes were just of strings
	-these days you can have a combobox of generics. they can be of anything... like.... aircrafts
	-this allows a custom displays. but it's yucky. so we aren't going to bother with it in class.
	-we're only gonna do string combo boxes for this class but maybe look into it for fun
	
class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ComboBox<String> combo = new ComboBox<String>();	//in Java you can leave out <Type> but it'll fuck you up reel good
			combo.getItems().addAll("One", "Two", "Three");		//by default, nothing is selected in combobox
			add(combo, 0, 3);									//but when you pick something you can't go back to nothing
			
			//what if one element has more than one setOnAction thing? The most recent one is the one that happens. Set replaces instead of adds!!!!
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(										//this is now dead code
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().bind(Bindings.not(cb.selectedProperty()));
			b.setOnAction(										//this replaces the last one
				(event) -> System.out.println(combo.getValue())
			);
			
}}

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ComboBox<String> combo = new ComboBox<String>();
			combo.getItems().addAll("One", "Two", "Three");
			add(combo, 0, 3);
			
			combo.valueProperty().addListener(
				(observable, old_val, new_val) -> {	//note: reselecting the same value doesn't 
					System.out.println(new_val);	//count as a change, so it won't fire off this event
				}
			);
			
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(										//this is now dead code
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().bind(Bindings.not(cb.selectedProperty()));
			b.setOnAction(										//this replaces the last one
				(event) -> System.out.println(combo.getValue())
			);
			
}}

--------------------
------08-31-17------
--------------------

Text widgets!

Graphics kits can support a TextLine (single line), TextBox (multiline), and some kind of Rich Text Control (styling included). RTC can be hella complicated, and varies between graphics kits, so we won't go too deep into it for this class. Some kits don't have separate modules for TextLine and TextBox (but not JavaFx since v.2). 

RW Properties in JavaFx are like "get__", "set__", and "__Property".

intro to TextField:

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);						//doesn't automatically reach best size
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())	//prints field's text to terminal
		);
		
		
	}
}

you can make pressing enter also always cause print.

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
			
		b.setDefaultButton(true);	//button turns blue to indicate it's default, means pressing enter causes this to go
	}
}

a different way to do it form inside textField

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		//Having both still only prints the first one (field.setOnAction(...) because
		//the defaultButton thing only goes into effect IFF no one else is using that enter key
	}
}

add TextArea

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		
		//weirdly, the textbox and textfield reach full size of window. 
		//they share a column, so the area made whole column got bigger, so the field grew.
		//if you expand window, they will keep growing until textfield finds it's 
		//default with.
	}
}

set expand size for TextArea

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);	//now that shit will grow forever. 
		setVgrow(area, Priority.ALWAYS);	//same for textfield because it's in that column
											//button won't grow by default
	}
}

Time for some Rich Text!!!!!!! in JavaFx, we use an HTML editor. Now, having the DefaultButton means enter will result in print. HTML doesn't use enter because the devs were like... this is ambiguous and we're scared so we won't do it.
Not every JavaFx distribution has HTML because life is unfair. You gotta install the preview of JDK 9.0. So if cross-platform development is important, maybe ignore the HTML becuase it's not everwhere. 

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);
		setVgrow(area, Priority.ALWAYS);
		
		HTML editor = new HTML();
		add(editor,0,4);
		//automatically has the styling buttons that most RTF editors have. 
	}
}

field prompt text

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		field.setPromptText("put words");
		//text does away when you select the field
		
		Button butt = new Button("Print");lr
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);
		setVgrow(area, Priority.ALWAYS);
		
		HTMLEditor editor = new HTMLEditor();
		add(editor,0,4);
	}
}

HOMEWORK! due on Sep 7th

	col1		col2		col3		col4
---------------------------------------------------------
|	o check1	o check2				[print but]		|
|										[submit but]	|
|	0 ra1		0 rb1									|
|	0 ra2		0 rb2									|
|	0 ra3		0 rb3									|
|														|
---------------------------------------------------------

when you hit submit, you append current status of each group/check/etc and stuff to message history.
when you hit print, print all of message history to terminal

--------------------
------09-05-17------
--------------------

Progress bar! Contains percentage done for a task. 
Sometimes it supports an indeterminate state (goes back and forth) for when task's progress is unknown. If it stops moving that means the task froze up, that means the event loop is no logner running, so the user knows the program fucked up.
main:
	set-up
	loop
		update state
		dispatch events
		//idle	<- olden days!!!! break up a big job into teeny tiny ones. good for progress bar, but awkward.
		redraw
	clean-up
	
Nowadays, just use threading. good: if thread fucks up, program still tuns. bad: time gets weird. if time isn't synched, and progress bar updates during the redraw, then you get issues and you can corrupt your state. This means, with another thread, you need to do extra wiring to make things talk in a safe way. We will talk about how to do this later.

For today we are just gonna hook the progress bar to a slider and worry about threads another day.

Sliders! Tracks current value, min/max, and type (int, double, etc.). Different kits do it differently. 

HELPFUL IMPORTS:
	javafx.scene.layout.*;
	javafx.scene.image.*;
	javafx.control.*;
	javafx.beans.*;

practice time! basic progress bar

class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0);		//when there's no configuration, it's just indeterminate state
		setHgrow(bar, Priotiy.ALWAYS);
		//the javafx fools have decided to treat progress bars like buttons, so they don't naturally change size. 
		//so you gotta manually set size to be huge for it to grow. but this can still break shit. thanks Oracle.
	}
}

class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator(); //it's the spinny wheel!
		add(ind,2,0);
		//indeterminate when value is less than zero
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
				//note: by default progress things go form 0.0 to 1.0 while 
				//slider goes from 0.0 to 100.0 so it obviously fills up progress fast.
		add(slider,0,1,2,1); //extra things are span so that it goes across columns
		
		bar.progressProperty().bind(slider.valueProperty());	//fills up
		int.progressProperty().bind(slider.valueProperty());	//becomes a checkbox basically
		
	}
}

time for container widgets and decorators. they contain other widgets and add extra bits. 
decorators (type of containers?):
	border widget: takes other component and draws a border around it
	scroll: lets you scroll through a widget and it stays small
container:
	GridPane (duh)
	
class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator();
		add(ind,2,0);
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
		add(slider,0,1,2,1);
		
		bar.progressProperty().bind(slider.valueProperty());
		int.progressProperty().bind(slider.valueProperty());
		
		Image img = new Image("file:trash.jpeg");
			//takes a URI instead of a filename because fuck you that's why
			//in something like NetBeans, image can be inside your jar file
		ImageView iview = new ImageView(img);
		add(iview,0,2,2,1);
		
	}
}

put iview in a scroll pane

class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator();
		add(ind,2,0);
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
		add(slider,0,1,2,1);
		
		bar.progressProperty().bind(slider.valueProperty());
		int.progressProperty().bind(slider.valueProperty());
		
		Image img = new Image("file:trash.jpeg");
		ImageView iview = new ImageView(img);
		
		ScrollPane scroller = new ScrollPane();
		add(scroller,0,1,1,2);
		scroller.setContent(iview);
		//note: scroller automatically dissapears when no longer needed
	}
}

Some graphical kits automatically add invisible scrollers around the thing, just set them visible. 
another scrolling example

class PanelWidget{//custom shit};

class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator();
		add(ind,2,0);
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
		add(slider,0,1,2,1);
		
		bar.progressProperty().bind(slider.valueProperty());
		int.progressProperty().bind(slider.valueProperty());
		
		Image img = new Image("file:trash.jpeg");
		ImageView iview = new ImageView(img);
		
		PanelWidget panel = new PanelWidget();
		
		ScrollPane scroller = new ScrollPane();
		add(scroller,0,1,1,2);
		scroller.setContent(panel);	//you can put scroll around any widget, not just an image
	}
}

time for tabs


class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator();
		add(ind,2,0);
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
		add(slider,0,1,2,1);
		
		bar.progressProperty().bind(slider.valueProperty());
		int.progressProperty().bind(slider.valueProperty());
		
		Image img = new Image("file:trash.jpeg");
		ImageView iview = new ImageView(img);
		
		PanelWidget panel = new PanelWidget();
		
		ScrollPane scroller = new ScrollPane();
		add(scroller,0,1,1,2);
		scroller.setContent(panel);
		
		TabPane pane = new TabPane();
		add(pane,0,3,2,1);
		
		Button b = new Button("Add tab");
		add(b,1,4);
		b.setOnAction(
			(event) -> {
				Tab t = new Tab();
				t.setText("New tab");
				t.setContent(new ImageView(img));	//imageview need to be remade because it can only show up once
				pane.getTabs().add(t);
			}
		);
		
		
	}
}

--------------------
------09-14-17------
--------------------

We are going to do an extra class on menus, may do classes on other toolkits. This is to not be too ahead of syllabus. Also attendance is gonna be a thing. 

Windows and dialog boxes

When you get multiple windows, how do you know when to close your application? Different toolkits deal with it differently. JavaSwing has a Window.OnClose() event. JavaFX and others by default end the application when all visible windows have closed. 

Modality--tells us the stacking order of a window. So if A can create B, A can OPTIONALLY e B's parent. With modality, as long as B is active, it blocks A and prevents interraction with A. A isn't necessarily disabled, it still renders and stuff, you just can't input anyhting. In JavaFX you need the parent relationship for this to work.

Consider a button in window A that shows window B. Normally, both windows are still inside a single event loop. 
event {
	callback {
		Window B = new BWin();
		B.BlockingShow(); 		//so if this is where program waits for input then
		print(B.property()); 	//to not break everything, it must spawn a new event loop
	}
}

Almost every windowing kit on the planet lets you do dialog boxes, and lets you skip all the extra steps of dealing with regular windows. 
Two types we'll cover: alerts and file choosers. Color pickers and prints are others that often exist. JavaFX's alert doesn't look like the system's alert. The file browser does though!

public class RunnerWindow extends Application{
	@Override
	public void start(Stage primaryStage){
		AlertWidget aw = new AlertWidget();
		aw.setAlightment(Pos.CENTER);
		
		primaeyStage.setTitle("inclass");
		primaryStage.setScnene(new Scene(aw,400,400);
		primaryStage.show();
	}
}

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.show();
			}
		)
		//this new window returns to the main event loop so you aren't blocking this AlertWidget with windowB
		//all windows must be closed for app to end
		
	}
	
	private Window getOwnerWindow(){ //you have to build this helper yourself :/
		Scene parentScene = this.getScene(); //is null when if it's never added to a node in the scene. 
		if (parentScene != null){
			return parentScene.getWindow();	//still nullable!! if scene hasn't been added to a window
		}
		return null;
	}
}

if you want to make your new stage modal with respect to the parent:

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				//modality can be to Application, Window, None. determines what gets blocked
				//for window modality you need to set the parent!
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		)
	}
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

more stuff with modality


public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		)
	}
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

basic alert

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		);
		
		Button alertB = new Button("Alert");
		add(alert,1,0);
		alertB.setOnAction(
			event -> {
				Alert a = new Alert(AlertType.CONFIRMATION);
				a.showAndWait();
				//automatically blocks other windows
			}
		);
	}
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

better alert

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		);
		
		Button alertB = new Button("Alert");
		add(alert,1,0);
		alertB.setOnAction(
			event -> {
				Alert a = new Alert(AlertType.CONFIRMATION, "Class is almost over!", ButtonType.OK, ButtonType.FINISH); 
				//Java's being like C#, doing the var args thing. Infinite button arguments allowed!
				Optional<ButtonType> result = a.showAndWait(); //this returns the selected button
				//Optional is a trivial object that allows result to be present or null. ButtonType is an enum and can't be null so you gotta do it
				//Optional is in Java.util
				if (result.isPresent() && result.get() == ButtonType.OK){
					System.out.println("Woo");
				}
			}
		);
	}
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

--------------------
------09-19-17------
--------------------

Menus

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button window = new Button("Window");
		add(window,0,0);
		Window.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		);
		
		Button alert = new Button("Alert");
		add(alert,1,0);
		alertB.setOnAction(
			event -> {
				Alert a = new Alert(AlertType.CONFIRMATION, "Class is almost over!", ButtonType.OK, ButtonType.FINISH); 
				//Java's being like C#, doing the var args thing. Infinite button arguments allowed!
				Optional<ButtonType> result = a.showAndWait(); //this returns the selected button
				//Optional is a trivial object that allows result to be present or null. ButtonType is an enum and can't be null so you gotta do it
				//Optional is in Java.util
				if (result.isPresent() && result.get() == ButtonType.OK){
					System.out.println("Woo");
				}
			}
		);
	}
	
	//here's the new thing
	Button save = new Button("Save");
	add(save,2,0);
	save.setOnAction(
		(event) -> {
			FileChooser chooser = new FileChooser();
			chooser.setTitle("Choose a file");
					//there's also a way to do this where you only check for a single file
			List<File> fs = chooser.showOpenMultipleDialog(getOwnerWindow);
					//it can return null so you need to check for it
			if (fs != null){
				for (File f: fs){
					System.out.println(f.getName());
				}
			} else {
				System.out.println("Nothing was selected.");
			}
		}
	);
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

now file searching but with filters (so its like *.jpeg)

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button window = new Button("Window");
		add(window,0,0);
		Window.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		);
		
		Button alert = new Button("Alert");
		add(alert,1,0);
		alertB.setOnAction(
			event -> {
				Alert a = new Alert(AlertType.CONFIRMATION, "Class is almost over!", ButtonType.OK, ButtonType.FINISH); 
				//Java's being like C#, doing the var args thing. Infinite button arguments allowed!
				Optional<ButtonType> result = a.showAndWait(); //this returns the selected button
				//Optional is a trivial object that allows result to be present or null. ButtonType is an enum and can't be null so you gotta do it
				//Optional is in Java.util
				if (result.isPresent() && result.get() == ButtonType.OK){
					System.out.println("Woo");
				}
			}
		);
	}
	
	//here's the new thing
	Button save = new Button("Save");
	add(save,2,0);
	save.setOnAction(
		(event) -> {
			FileChooser chooser = new FileChooser();
			chooser.setTitle("Choose a file");
			
			chooser.getExtensionFilters().addAll(
				new ExtensionFilter("Source files","*.java", "*.py"),
				new ExtensionFilter("All Files","*");
			);
			//these extension filters show up in chooser and allow user to select between them
			
			List<File> fs = chooser.showOpenMultipleDialog(getOwnerWindow);
			
			if (fs != null){
				for (File f: fs){
					System.out.println(f.getName());
				}
			} else {
				System.out.println("Nothing was selected.");
			}
		}
	);
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

--------------------
------09-21-17------
--------------------

Menus! It's always pushed against the top of the container and is as wide as its parent. 
javafx.scene.control.MenuBar 	-> represents the entire bar
javafx.scene.control.Menu 		-> represents the items inside the menu. File, edit, etc.
javafx.scene.control.MenuItem	-> represents the submenus inside file, edit, etc

In other kits there is the concept of the abstract command. A command is a single point of implementation for some piece of application state. The idea is that if you have one [[ edit > cut ]] option, you have to store whatever's selected into the clipboard. Command allows you to package the action you do with the application state, plus other needed references, to do the thing. WPF and JavaSwing both have these things, and they're useful as hell.
Java FX doens't have it. You can kind of acheive the same result with action listeners. ActionListener<ActionEvent> { .... } won't be covered in class but it's an option for projects.

We're going to make a menu bar with one menu and one submenu. Going to start form the bottom up, just because it's easier. This time we're extending from VBox instead of GridPane, it's a layout container, too, just easier to get the menu where you want it. 

class MenuWidget extends VBox {
	class MenuWidget(){
		MenuBar bar = new MenuBar();
		Menu menu = new Menu("File");
		
		MenuItem open = new MenuItem("Open");
		MenuItem save = new MenuItem("Save");
		
		menu.getItems().addAll(open, save);
		
		this.getChildren().addAll(menu);
	}
}

At its current state, the menu bar is in the middle of the window! It's just a normal node, not meant to be attatched to the top by default. Gotta fix the location by setting the vertical grow priority.

class MenuWidget extends VBox {
	class MenuWidget(){
		MenuBar bar = new MenuBar();
		Menu menu = new Menu("File");
		
		MenuItem open = new MenuItem("Open");
		MenuItem save = new MenuItem("Save");
		
		menu.getItems().addAll(open, save);
		
		this.getChildren().addAll(menu);
		
		GridPane pane = new GridPane();
		this.getChildren().add(pane);
		VBox.setVgrow(panel, Priority.ALWAYS); //static method so can't use keyword this
		//now the menu's at the top!
	}
}

Remember that the gridpane takes its size from its largest child. At this time it has no children. A GridPane with growth priotity always has a size of zero in the top left corner, but it has an allocation of the entire white space of the window below the menu, and that's why the menu is pushed to the top. 

class MenuWidget extends VBox {
	class MenuWidget(){
		MenuBar bar = new MenuBar();
		Menu menu = new Menu("File");
		
		MenuItem open = new MenuItem("Open");
		MenuItem save = new MenuItem("Save");
		
		menu.getItems().addAll(open, save);
		
		this.getChildren().addAll(bar);
		
		GridPane pane = new GridPane();
		this.getChildren().add(pane);
		VBox.setVgrow(panel, Priority.ALWAYS); //static method so can't use keyword this
		//now the menu's at the top!
		
		pane.setStyle("-fx-grid-lines-visible: true; -fx-stroke: black;"); //adds gridlines that aren't debugger lines
		
		Button b = new Button("b");
		pane.add(b,0,0);
		
		//when you run itll show that the box only extends to the exact size of the button.
		
	}
}

adding actions to menu items.

Note: vboxes have it so that all children by default get the full horizontal allocation, which is good for menus! Thigns like the progress bar still won't grow because Oracle loves to make questionable choices.

class MenuWidget extends VBox {
	class MenuWidget(){
		MenuBar bar = new MenuBar();
		Menu menu = new Menu("File");
		
		MenuItem open = new MenuItem("Open");
		MenuItem save = new MenuItem("Save");
		
		GridPane pane = new GridPane();
		this.getChildren().add(pane);
		VBox.setVgrow(panel, Priority.ALWAYS);
		
		save.onAction(
			(event) -> {
				System.out.println("save clicked");
				
			}
		);
		
		SeperatorMenuItem sep = new SeperatorMenuItem();
		
		Menu recents = new Menu("Recent items");
		
		MenuItem lies = new MenuItem("Lies");
		MenuItems secrets = new MenuItem("Secrets");
		
		recents.getItems().addAll(lies, secrets);
		
		menu.getItems().addAll(open, save, sep, recents);
		
		bar.getMenus().addAll(menu);
		
		this.getChildren().addAll(bar);
		
	}
}

Now it's time to switch languages! GTK3 in Python! But in Python, Qt is better, but David Bolding has never used it so can't easily teach it to us on short notice. GTK3 is a little bit weird, it's very old and has been around for a long time. GIMP, that image program, had a graphical abstraction layer, and they branched it off into its own opensource toolkit. Most applications on Linux use it.

GTK was originally done in C. So they made the glib library, which is object oriented for C. It builds pseudo object oriented techniques using C macros on top of C structs. If you actually write a GTK program in C, it'll be super verbose. It's awkward and impractical. Because of this, GTK has branched out to other languages. They even made the language Vala, which looks like C#, but compiles into C, so there are some weird limitations (like no exceptions!)

So, python. You could use PYGTK, but its slow to update and only works up to v2. So for v3 onward, use Python G-object introspection. Introspection means, given an object you know nothing about, you can still load it up and use it. 

Is it reflection?? Kinda but no. See https://en.wikipedia.org/wiki/Type_introspection

With introspection, intellisense won't work, because it wants to see the whole library. That's because when you use introspection, the namespace is filled in at runtime, which just isn't compatible. 

Note: GTK appllications aren't the most Windows friendly. It's meant for Linux.

{

#! /usr/bin/python3

import gi
gi.require_version("Gtk","3.8");
from gi.repository import Gtk

win = Gtk.Window(title="Weakly-Typed window")

win.connect("delete-event". Gtk.main_quit)
	//this makes it to the exit button actually ends the program
	//.main_quit is a function that actually does the shut down action

win.show_all() //shows this window and any of its children


Gtk.main()

}

Weakly typing is similar to dynamic typing (where vars can change types). Weak typing means they don't have a well-defined type at runtime. A type is decided based on methods it has. So it doesn't enforce type restrictions, and python assumes you're following the rules. Doesn't this make it slower?

Python is functional, you can can carry functions around like variables and just give it to stuff. Good for this!

{

#! /usr/bin/python3

import gi
gi.require_version("Gtk","3.8");
from gi.repository import Gtk

win = Gtk.Window(title="Weakly-Typed window")

hbox = Gtk.Box()
win.add(hbox)

firstB = Gtk.Button.new_with_label(label="first!")
	//.new_with_label() is a factory method!!!!!!
hbox.pack_start(firstB, True, True, 3)
	//packs in from the beginning of the box. with an hbox the beginning is the left. it's like a load-in bay??
	//second is grow allocation
	//third if fill 
	//fourth is padding
	//so this appears in the very center of the window because its allocation lets it!!! 
	//there's padding around the left and right edes of the window outside the allocation

win.connect("delete-event". Gtk.main_quit)

win.show_all()


Gtk.main()

}

more on this

{

#! /usr/bin/python3

import gi
gi.require_version("Gtk","3.8");
from gi.repository import Gtk

win = Gtk.Window(title="Weakly-Typed window")

hbox = Gtk.Box()
win.add(hbox)

firstB = Gtk.Button.new_with_label(label="first!")
hbox.pack_start(firstB, False, True, 3)
	//grow is false, now button is on left side. stille xpands infinitely vertically, because it fills the row basically
	//if fill is false as well, it is the same as before. this is because the allocation doens't change, so fill won't either
	//if grow is true and fill is false, it hits its preferred horizontal size and lands right in the middle of the window.

win.connect("delete-event". Gtk.main_quit)

win.show_all()


Gtk.main()

}

There's Glade, a graphical Gtk builder. Niiice.

{

#! /usr/bin/python3

import gi
gi.require_version("Gtk","3.8");
from gi.repository import Gtk

win = Gtk.Window(title="Weakly-Typed window")

hbox = Gtk.Box()
win.add(hbox)

firstB = Gtk.Button.new_with_label(label="first!")
hbox.pack_start(firstB, False, True, 3)

secondB = Gtk.Button.new_with_mnemonic(label="second")
secondB.connect("clicked", lambda widget: print("I was clicked"))
	//^ this is a lambda expression!!!! 
	//widget is the argumement name, thing after the colon is what to do next
hbox.packstart(secondB,True,True,3)

win.connect("delete-event". Gtk.main_quit)

win.show_all()

class ExWindow(Gtk.Window):
	def __init__(self, title):
		super().__init__(title=title)
		
		hbox = Gtk.Box()
		butt = Gtk.Button.new_with_mnenomic(labek="click me")
		butt.connect("clicked",self.clicked)
		hbox.pack_start(butt, true,true,10)
		self.add(hbox)
		
	def clicked(self,source):
		print("clicked")
		
e.exWindow(title="hot potato")
e.show_all()

Gtk.main()

}

In python, self is basically this. def __init(self) is a constructor. You have to explicitly call your superclass's constructor. 
self.clicked in butt.connect("clicked",self.clicked) is actually a bound method. This means the e object gets a clicked method that has one argument, and just calls that. so what's happening is this: e.clicked = lambda source: ExWindow.clicked(e, source)
Basically, it's a weird method that, behind the scenes, magics its way into working. Magic is the worst. 

--------------------
------10-05-17------
--------------------

FXML! Note, Java cannot tightly integrate with FXML like some other kits do. If you are using an IDE to get FXML into your application, the steps to take will be different than what the professor does. He does uses FileStream to read layout.fxml but I can't necessarily do that.

public void Start(Stage stage){
	try {
		FileInputStream istream = new FileInputStream("layout.fxml");
		FXMLLoader loader = new FXMLLoader();
		Parent root = loader.load(istream);
		
		Scene scene = new scene(root, 600, 600);
		
		stage.setTitle("A test");
		stage.setScene(scene);
		
		stage.show();
	} catch (exception e){
		System.out.print(e.getMessege());
	}
}

Layout.fxml

	<xml version="1.0" encoding="UTF-8"?>
	<?language javascript>

	<?import java.net.*?>
	<?import javafx.geometry.*?>
	<?import javafx.scene.control.*?>
	<?import javafx.scene.layout.*?>
	<?import javafx.scene.text.*?>
	<?import javafx.scene.web.*?>

	<GridPane fx:controller="Controller"
		xmlns:fx="http://javafx.com/fxml" alignment"center" hgap="10" vgap="10">
		
		<TextField text="Sample Text" fx::id="tf"
			GridPane.columnIndex="0" GridPane.RowIndex="0" />
		
		<Button text="Click Me"
			GridPane.columnIndex="0" GridPane.RowIndex="1" 
			onAction="tf.setText('clicked');"/>
			
	</GridPane>

Doing the same onAction but with a script!

	<xml version="1.0" encoding="UTF-8"?>
	<?language javascript>

	<?import java.net.*?>
	<?import javafx.geometry.*?>
	<?import javafx.scene.control.*?>
	<?import javafx.scene.layout.*?>
	<?import javafx.scene.text.*?>
	<?import javafx.scene.web.*?>

	<GridPane fx:controller="Controller"
		xmlns:fx="http://javafx.com/fxml" alignment"center" hgap="10" vgap="10">
		
		<fx::script>
			function handle_click(event){
				tf.setText("clicked!");
			}
		</fx::script>
		
		<TextField text="Sample Text" fx::id="tf"
			GridPane.columnIndex="0" GridPane.RowIndex="0" />
		
		<Button text="Click Me"
			GridPane.columnIndex="0" GridPane.RowIndex="1" 
			onAction="handle_clicked(event)"/>
			
	</GridPane>
	
Note that "Controller" is the name of the class here. If it were in a package it would be named Package.Controller or something. Here is how you link a Java class to an FXML class.

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.event.ActionEvent;

public class Controller{
	//FXML is linked to the java class via introspection. 
	@FXML protected TextField tf = null;
	
	@FXML protected void handle_click_java(ActionEvent e){
		tf.setText("handled in java");
	}
}

<xml version="1.0" encoding="UTF-8"?>
	<?language javascript>

	<!-- import statements --/>

	<GridPane fx:controller="Controller"
		xmlns:fx="http://javafx.com/fxml" alignment"center" hgap="10" vgap="10">
		
		<fx::script>
			function handle_click(event){
				tf.setText("clicked!");
			}
		</fx::script>
		
		<TextField text="Sample Text" fx::id="tf"
			GridPane.columnIndex="0" GridPane.RowIndex="0" />
		
		<Button text="Click Me"
			GridPane.columnIndex="0" GridPane.RowIndex="1" 
			onAction="#handle_click_java)"/>
			
	</GridPane>
	
Adding more widgets!!

<xml version="1.0" encoding="UTF-8"?>
	<?language javascript>

	<!-- import statements --/>

	<GridPane fx:controller="Controller"
		xmlns:fx="http://javafx.com/fxml" alignment"center" hgap="10" vgap="10">
		
		<fx::script>
			function handle_click(event){
				tf.setText("clicked!");
			}
		</fx::script>
		
		<TextField text="Sample Text" fx::id="tf"
			GridPane.columnIndex="0" GridPane.RowIndex="0" />
		
		<Button text="Click Me"
			GridPane.columnIndex="0" GridPane.RowIndex="1" 
			onAction="#handle_click_java)"/>
			
		<ProgressBar
			Progress="${sb.value}"
			GridPane.RowIndex="1" GridPane.ColumnSpan="2" 
			/>
			
		<ScrollBar fx::id="sb"
			GridPane.RowIndex="2" GridPane.ColumnSpan="2" 
			min="0.0" max="1.0" />
			
	</GridPane>
	
Some gotchas: the corresponding Java class MUST be public, even if its members can be protected or private. 
Note, multiple FXML files can have the same Java file!!! Whaaaat

Next we're gonna learn about Glade!!!!! That's me!!! It's in python, UI generates XML stuff.

	import gi
	gi.require+version("Gtk", '3,0")
	from gi.repository import Gtk

	builder = Gtk.Builder()
	builder.add_from_file("ex.glade") 	//ex.glade is the generated xml file

	def handle(source):
		print("clicked")
	
	callbacks = {
		//creates a dictionary where "handle_click" refers to this function
		"handle_click": handle
	}
	
	print(type(callbacks["handle_click"]))
	
	ex = builder.get_object("ex")
	ex.show_all()

	Gtk.main()
	
	
--------------------
------10-10-17------
--------------------

How to pass ifo between classes. What if you want to start a download in one widget by pressing a button in a different widget? You need special listeners and custom events to preserve encapsulation and still do the thing.

The Observer Pattern
	Event callback system. Hinges on an interface called a Handler, with a single function handle(). The subject emits widgets, and has as a member, a list of handlers. When the subject wants to emit an event, it loops over its list of handlers and calls each handle function. We also have the ability to add a new handler to the list with addHandler(). 
	So you could make a new class extend Handler and then override the handle() method. Java doesn't have its own default high level event system, you have to implement it yourself kind of. 
	
So for URLWidget, which needs to output a url for DownloadWidget to download from, you'd need to use the custom interface URLHandler. It might have a method like handleUrl(string url) which returns void. Note, some kits let you return something nonvoid for handle methods, but it isn't absolutely necessary.
Then, in the URLWidget, you need to have something like 
		for (h : urlHandlers){ h.handleUrl(blah.getText()); }
You would put that inside the callback for the event that you want to effect the other DownloadWidget. 

In Python you can do something like:
	callbacks = list()
	def my_cb()
		pall
	callbacks.append(my_cb)
	for cb in callbacks:
		cb()

In C# it is of course the best. 
	
	delegate void
		handle_url(String url)
		
	class MyClass{
		event handle_url
			url_submitted;
	}
	
		MyClass.url_submitted += () => Console.WriteLine();
		
Example time! (In Java)

public interface TestObserver extends Handler {
	public void Notify();
}

public class TestSubject{
	private Vector<TestObserver> observers = new Vector<Observers>
	
	public void AddTestEvent(TestObserver to){
	observers.add(to);
	
	public void removeTestEvent(TestObserver to){
		observers.remove(to);
	}
	
	public void fireTestEvent(){
		for (TestObserver to: observers)
			to.Notify();
	}
}

In our HWs, TestSubject would just be whatever graphical class we're working on. If HW requires us to do an event handling thing, that's 50% of the grade.

--------------------
------10-12-17------
--------------------

Event handling example. 

@FunctionalInterface
public interface BasicHandler {
	public void handle(String string);
}

public class BasicWidget extends GridPane{
	
	public Vector<BasicHandler> handlers = new Vector<BasicHandler>();
	
	public BasicWidget(){
		TextField tf = new TextField();
		add(tf,0,0);
		
		Button b = new Button("Submit");
		add(b,1,0);
		
		b.setOnAction(
			(event) -> {
				String str = tf.getText();
				for (BasicHandler bh : handlers) {
					bh.handle(str);
				}
			}
		);
	}
	
	public addBasicHandler(BasicHandler bh){
		handlers.add(bh);
	}
}

public class BasicRunner extends Application {
	@override
	public void start(Stage stage) {
		BasicWidget root = new BasicWidget();
		root.addBasicHandler{
			(String str) -> System.out.println(str);
		}
	);
	
	Scene scene = new Scene();
	stage.setScene(scene);
	stage.show();
}

How to do this for FXML? Really similar to old FXML example, just include those extra bits for handling.

Next up: the MVC pattern! 

Model: It's nongraphical. It knows how to perform the actual tasks you want to perform, or use other components that do. It has functions to start operations and it has events to report status.
View: display current state. It doesn't know about the model. It has events to represent user action and functions to display states.
Controller: Defines the behavior of the interface of viewer and ties model and view together. Model and view shouldn't talk directly to eachother, they don't know eachother!

Say you have a main window with two parts, red and green. Green contains a text field next to a button. Red contains a list of progress bars with cancel buttons. There is also a download engine. It is most reasonable to break this up into smaller widgets. This can get complicated when widgets need to talk to eachother. 
You could argue the Donwload engine is a model 

--------------------
------10-19-17------
--------------------

NOTE: missed last class, so some info may be incomplete. It's kind of hard to find good doc umentation on how to do observer pattern in Java, just because it's kind of messy and people just avoid talking about it.

Another summary of Observer Pattern:
	-interface for callback
	-list of interfaces/listeners
	-iterate over listeners to call each handle()
	
code examplessssss not complete:
	
public class RssView extends VBox {
	private VBox entriesBox;
	private TextField pathField;
	
	private Vector<PathHandle> pathHandlers;
	
	public RssView(){
		setSpacing(8.0);
		
		HBox top = new HBox();
		
		pathField = new TextField();
		
		Button open = new Button("Choose file");
		openButton.setOnAction(
			(ActionEvent event) -> {
				FileChooser chooser = new FileChooser();
				chooser.setTitle("Choose");
				....
			}
		);
		
		...
		
		top.getChildren.addAll(pathField, openButton, readButton);
		HBox.setHgrow(pathField, Priority.ALWAYS);
		
		pathHandlers = new Vector<PathHandler>;
	}
	
	...
	
	public void showError(String error){
		Alert a = new Alert(AlertType.ERROR);
		a.showAndWait();
	}
	
	...
}

public class RssController{
	RssView view = null;
	RssModel = null;
	
	public RssController(RssView view, RssModel model){
		this.view = view;
		this.model = model;
		
		view.addPathHandler(
			(String path) -> {
				try {
					mode.startFetch(path);
				} catch (RssException e) {
					view.showError(re.getMessege());
				}
			}
		);
		
		model.addResultHandler(
			(Vector<RssResult> results) -> {
				view.showResults(results);
			}
		);
		
		model.addErrorHandler(
			(String error) -> {
				view.showError(error);
			}
		);
		
		...
	}
	
	...
}

Moving on, couldn't get all the notes in time. Look into this later: https://www.javacodegeeks.com/2013/08/observer-design-pattern-in-java-example-tutorial.html

What to do about long running jobs? Use threads! Here's how to deal with multithreading. 

Main routine is always contained in the main thread. New threads can be created and terminated in the middle of the process. On some platforms you can even terminate the main thread and keep going as long as there is another thread running. Every language has a slightly different threading API, every operating system has a slightly different threading model. Unix/Linux systems are hella different from Windows. 

In Java, Thread has the method public void run(). One way to use this is to extend Thread and override that method. It's possible for a new thread to be run on a different processor entirely on modern systems. 

Given this, how do you get data out of the thread? If you have some objects (like a file object or something), your threads can access all the resources in the process and interract with those objects. What if two different threads try to access the same function on the same object at the same time?

Suppose you have a shared resource that is a database connection, C. You have thread A and thread B. At some point, A and B are running. Then A calls a method on C, and it beginds to operate. Then B does the same, so there is a window of time where C is being used by both threads. This might mangle the DB, because it's sending queries of two different operations. Unless you build coordination into the threads, they'll do dumb shit like this and garbage up the DB.

What you essentially need to do is acquire a lock, do the thing you want to do, and then release the lock. This lock blocks, and makes other threads wait for it to unlock. So for the example, A causes C to acquire the lock, do a thing, and then release. B will hit the acquire lock step and stop until it can do that. Its copy of the fucntion will run once the lock is released, then it acquires the lock and does the thing.

But what if you code generates an exception in a locked method? That means the lock release could never happen. Bugs can be really tough to solve, since they are so timing-based that they can be hard to recreate. 

So you have a long-running job. You can use these things:
	>idle-event. runs last in the event loop. You need to be able to chop your giant task up into tiny steps, which is hard as fuuuuck. File IO is a good example of something hard to break up; it can suddenly take a lot of time to do a step, and if it occures in your idle event, it'll lag everything up.
	>threading. Sharing resources is both useful and dangerous. If a thread directly changes the state of a thing in the middle of its rendering, shit can get weird and fuck up the display. So you need explicit synchronization. You need a rule like this: The states of widgets should never be altered form outside the main thread that owns them. 
	>background wokers. They do the work on the event thread, way easier to implement. JavaFX and JavaSwing follow this pattern differently: Swing did a good job, but JavaFX was like lol no only pass strings. So we aren't really gonna go into it with JavaFX in this class. 
	
JavaFX most prefers to do threading. 

--------------------
------10-24-17------
--------------------

Threading example

public class Contesters {
	public static void main(String[] args){
		StringBuffer sb = new StringBuffer();
		
		ContesterThread c1 = new ContesterThread(sb);
		ContesterThread c2 = new ContesterThread(sb);
		
		c1.start();
		c2.start();
		
		try{
			c1.join();
			c2.join();
		} catch (InterruptedException e){
			System.err.println("Managed exceptions are unforgivably stupid");
		}
		
		System.out.println(sb);
	}
}

public class ContesterThread extends Thread {
	StringBuffer sb = null;
	
	public ContestorThread(Stringbuffer sb){
		this.sb = sb;
	}
	
	@overridepublic void run(){
		for (int i = 0; i < 10; i++){
			sb.append("iteration: ");
			sb.append(i);
			sb.append("\n");
		}
	}
}
	
Sometimes in the Contestors class, they just step on eachother and get in the way. It happens at unpredictable times and mangles the buffer, so that you can get weird outputs like "Iteration: Iteration: 88"

The solution? To lock the thing. Use a block called synchronized:


public class ContesterThread extends Thread {
	StringBuffer sb = null;
	
	public ContestorThread(Stringbuffer sb){
		this.sb = sb;
	}
	
	@overridepublic void run(){
		for (int i = 0; i < 10; i++){
		synchronized(sb){
				sb.append("iteration: ");
				sb.append(i);
				sb.append("\n");
			}
		}
	}
}

Usually it looks like you get the output of one thread and then the other. Other times they intermindle (you you get two "Iteration: 1"s in a row). This is probably because there's more than one processor so they're actually simultaneous. 

Now for a more specific JavaFx example.

public class WaitAndAlert extends Application{
	@override
	public void start(Stage stage){
		VBox root = new VBox(8);
		
		TextArea text = new TextArea();
		text.setEditable(false);
		
		root.getChildren().add(text);
		VBox.setVGrow(text, Priority.ALWAYS);
		
		Button start = new Button9"start");
		startButton.setOnAction(
			(ActionEvent event) -> {
				Thread th = new Thread() {
					@Override
					public void run(){
						try{
							Thread.sleep(5000);
						} catch (Exception e) {
							//pass, fuck it
						}
					}
				};//anon thread class def
			}
		);
		
		th.start();
		//don't call run!!!!! call start. run will just hold up the event loop
	}
}

When you press the start button nothing will actually happen in the GUI, the new threads don't update the state, they're just sleeping in the background for 5 seconds. Let's update the GUI when they run. One way to do it is by using idle callbacks to check for state updates by the run method. 

public class WaitAndAlert extends Application{
	@override
	public void start(Stage stage){
		VBox root = new VBox(8);
		
		TextArea text = new TextArea();
		text.setEditable(false);
		
		root.getChildren().add(text);
		VBox.setVGrow(text, Priority.ALWAYS);
		
		Button start = new Button9"start");
		startButton.setOnAction(
			(ActionEvent event) -> {
				Thread th = new Thread() {
					@Override
					public void run(){
						try{
							Thread.sleep(5000);
						} catch (Exception e) {
							//pass, fuck it
						}
						
						Platform.runLater(new Runnable(){
								@Override
								public void run(){
									text.setText(
										text.getText() + "run completed!\n"
									);
								}
							}//anon Runnable class def
						);
					}
				};//anon thread class def
			}
		);
		
		th.start();
	}
}

The reason you do not have to synchronize the Platform.runLater stuff is because it is happening on the mian thread, so they're one at a time. 
There's a cleaner way.

public class WaitAndAlert extends Application{
	@override
	public void start(Stage stage){
		VBox root = new VBox(8);
		
		TextArea text = new TextArea();
		text.setEditable(false);
		
		root.getChildren().add(text);
		VBox.setVGrow(text, Priority.ALWAYS);
		
		Button start = new Button9"start");
		startButton.setOnAction(
			(ActionEvent event) -> {
				Thread th = new Thread() {
					@Override
					public void run(){
						try{
							Thread.sleep(5000);
						} catch (Exception e) {
							//pass, fuck it
						}
						
						//lambda expressions can replace all that stuff up there. You're still making an anonymous class definitions which gets expanded into a real class definition by the compiler.
						Platform.runLater(
							() -> text.setText(getText() + "I am a lambda and the run completed!\n")
						);
					}
				};//anon thread class def
			}
		);
		
		th.start();
	}
}

--------------------
------10-31-17------
--------------------

Rendering "drawings". how do you make graphics that don't already exist? How do you make it possible to interract with these graphics?

|-0--0--0-|
How would you draw circles of diameter d, with spaces s on each side of all the circles?
widget::render(canvas c)
	cur_center = s + r
	for p in page_count
		c.drawcircle(cur_center)
		c += c + s + l + s + r

widget::get_size()
	size = pagecount * d + 2*page_count*s + (pagecount-1)*1
	return size

idk this isn't great pseudocode, hard to follow handwriting.

public class Circles extends Pane {
	private Vector<PageRequestHandler> pageHandlers;
	private int pageCount;
	private int currentPage;
	private double padding;
	private double radius;
	
	public Circles(){
		pageHandlers = new Vector<PageHandlers>();
		pageCount = 0;
		currentPage = 0;
		padding = 0;
		radius = 0;
	}
	
	
	public void setPageCount(int count) throws CirclesException {
		if (count < 0){
			throw new CircllesException("Page count out of bounds");
		}
		
		pageCount = count;
		
		this.getChildren().clear();
		
		Double curCenter = padding;
		for (int i = 0; i < count; i++){
			Circle circle = new Circle(radius,Color.RED);
			circle.relocate(curCenter, padding);
			this.getChildren.add(circle);
			
			Integer I = new Integer(i);
			//why use an Integer, not an int?
			//because regular i CANNOT be marked final!!!
			
				//	circle.setOnMouseClicked(
				//		new EventHandler<MouseEvent>(){
				//			@Overridepublic void handle(MouseEvent me){
				//				emitPageEvent(I);
				//			}
				//		}
				//	);
			//remeber, above is a dumb way to do it, it can be shortened!!!
			//see below
			
			circle.setOnMouseClicked(
				(MouseEvent ev) -> emitPageEvent(I)
			);
			//i cannot be marked final, so you need to use I. 
			
			curCenter += radius + radius + padding;
		}
		
		this.setMinWidth(padding + (pageCount * (radius + radius + padding)));
		this.setMinHeight(padding + radius + radius + padding);
		
	}
	
	public void setCurrentPage(int page) throws CirclesException {
		if (page < 0 | page >= pageCount){
			throw CirclesException("out of range");
		}
		
		int cp = 0;
		
		for (Node n: this.getChildren()){
			if (n instanceof Circle){
			..... sets color stuff basically
			}
		}
	}
	
	public void addPageRequestHandler(PageRequestHandler handler){
		pageHandlers.add(handler);
	}
	
	public void emitPageEvent(int number){
		for (PageRequestHandler handler: pageHandlers){
			handler.handle(number);
		}
	}
}

Integer is essentially a boxing class. Since Integer is a class created with new and handled by reference, it's heap allocated instead of stack allocated. Heap memory only dissapears when the last reference goes away So for Java, Integer is a lexical bandaid. 
For Java, if a thing is a simple boxing type, it will automatically box or unbox for you (so you don't have to be like I.get() or something).
It's all just elaborate code beurocracy. 


--------------------
------11-07-17------
--------------------

Test next week on Thursday, 16th, and will cover HWs 3,4, and 5. After Thanksgiving week is the first week of project presentations.

Drag and drop! JavaFX does it in a pretty typical way, it's implemented as a series of events that you can respond to. Usually, commonly, you're going to have some set of ON_DRAG_ENTER, ON_DRAG_DROP, and ON_DRAG_LEAVE events. All NODE widgets have these events built in to them, which makes life easier.

public class DragApp extends Application {
	@Override
	public void start(Stage stage){
	InternalDrag id = new InternalDrag();
	FileDrag fd = new FileDrag();
	
	VBox root = nw VBox();
	...//you know the rest
	}
}


public class InternalDrag extends Pane{
	public InternalDrag(){
		Test source = new Text(START DRAG HERE);
		source.relocate(50.0,50.0);
		source.setFond(new Font(48.0));
		
		source.setOnDragDetected(
			(MouseEvent event) -> {
				Dragboard db = source.startDragAndDrop(TransferMode.ANY);
				ClipboardContent content = new ClipboardContent();
				content.putString(source.getText());
				//ClipBoards can accept a lot of different inputs, like files and stuff.
				
				db.setContent(content);
				event,consume();
				//consume tells the system to not continue to propogate this event. so do not push the event up
			}
		);
		
		source.setOnDragDone{
			...
		}
		
		text target = new Test(DRAG HERE);
		target.relocate(50.0,50.0);
		target.setFond(new Font(48.0));
		
		source.setOnDragOver(
			(DragEvent event) -> {
				if (event.getDragboard().hasString()){
					event.acceptTransferMode(TransferMode.MOVE);
				}
				event.consume();
			}
		);
		
		target.setOnDragDropped(
			(DragEvent event) -> {
				DragBoard db = event.getDragboard();
				boolean success = false;
				if (db.hasString()){
					System.out.ptintln(db.getString());
					success = true;
				}
				event.setDropCompleted(success);
				event.consume();
			}
		);
		
		target.setOnDragEntered(
			(DragEvent event) -> {
				if (event.getGestureSource() != target && event.getDragboard.hasString()){
					target.setFill(Color.GREEN);
				}
				event.consume();
			}
		);
		
		target.setOnDragExited{
			(DragEvent event) -> {
				target.setFill(Color.BLACK);
				event.consume();
			}
		}
	}

}

public class FileDrag extends Pane{
	public FileDrag(){
		Rectangle rect = new Rectangle();
		rect.relocate(50,50);
		rect.setWidth(300.0);
		rect.setHeight(100);
		sect.setFillColor(Color.LIGHTGREEN);
		
		rect.setOnDragEntered(
			(DragEvent event) -> {
				if (event.getDragBoard().HasFiles()){
					event.acceptTransferModes(TransferMode.COPY);
				}
			}
		);
		
		rect.setOnDragOver(
			(DragEvent event) -> { 
			if (event.g
			}
		
		);
		
		rect.setOnDragDropped(
			DragEvent event) -> {
				//save file paths of all files dragged inside and print them
				if (event.getDragBoard().HasFiles()){
					for (File f: event.getDragBoard().getFiles()){
						System.out.println(f.getPath());
					}
				}
				event.consume();
			}
		);
	
	}
}

I just can't really type fast enough to keep up, sigh. But this system for file dragging is kind of buggy, beware. 

--------------------
------11-09-17------
--------------------

Java Animation! 
There is a Timeline class, which contains a list of Keyframes. Those Keyfreames contain a list of KeyValues. Those KeyValues have properties with values.
The Timeline keeps references to all of those properties and properties' properties. if your Timeline is infinite (which is possible) it can cause memory leakage problems, because it stops some of the references from being garbage collected. 
David's advice: keep your animation precise, don't reuse things, simpler is more efficient.
Time to look at the code. See the AnimationDemo folder. Source code taken from iCollege.

import javafx.util.Duration;

import javafx.scene.paint.*;

import javafx.scene.layout.Pane;
import javafx.scene.shape.*;
import javafx.scene.control.*;

import javafx.scene.input.*;

import javafx.animation.*;

import javafx.event.ActionEvent;

import javafx.beans.binding.*;


public class CircleMover extends Pane {
    private enum States {
        INITIAL, CLICKED, ANIMATING;
    }

    private States curState = States.INITIAL;

    private double firstX, firstY, secondX, secondY;

    private Circle animCircle;

    public CircleMover() {
        this.setOnMouseClicked(
            (MouseEvent event) -> handleClick(event)
        );

        this.animCircle = new Circle();
        animCircle.setVisible(false);
        animCircle.setRadius(50.0);
        animCircle.setFill(Color.RED);
        this.getChildren().add(animCircle);

        this.setPrefSize(Double.MAX_VALUE, Double.MAX_VALUE);
        //ensures that the circle widget takes up the entire avaliable window

        /*
       // this is written by bolding!!!!
        
        Button sb = new Button("Start");
        sb.translateXProperty().bind(Bindings.subtract(this.widthProperty(), Bindings.add(sb.widthProperty(), 15)));
        sb.translateYProperty().bind(Bindings.subtract(this.heightProperty(), Bindings.add(sb.heightProperty(), 15)));
        this.getChildren().add(sb);
        */
    }

    private void handleClick(MouseEvent me) {
        System.out.println(curState);

        if (curState == States.INITIAL) {
            firstX = me.getX();
            firstY = me.getY();

            curState = States.CLICKED;
        } else if (curState == States.CLICKED) {
            secondX = me.getX();
            secondY = me.getY();

            curState = States.ANIMATING;

            startAnimation();
        }
        // ignore clicks during animation
    }

    private void startAnimation() {
        Timeline tl = new Timeline();
        
        //getting the x position (translateXProperty) as an argument and associating it with firstX, repeat with Y
        KeyFrame start = new KeyFrame(Duration.millis(0),
                                      new KeyValue(animCircle.translateXProperty(), firstX),
                                      new KeyValue(animCircle.translateYProperty(), firstY));
        //at the 5th second, the properties should be at the second X and Y
        KeyFrame end = new KeyFrame(Duration.millis(5000),
                                    new KeyValue(animCircle.translateXProperty(), secondX),
                                    new KeyValue(animCircle.translateYProperty(), secondY));
        //now adding to the animation. parts between keyframes get filled in 
        tl.getKeyFrames().addAll(start, end);
        
        //you could declare those two keyframes in different orders and it wouldn't matter. 
        //it's Duration.millis() that determines when it happens in the animation.

        tl.setOnFinished(
            (ActionEvent ev) -> {
            	//init the circle and make it invisible
                curState = States.INITIAL;
                animCircle.setVisible(false);
            }
        );

        //make circle visible and start playing the animation
        animCircle.setVisible(true);
        tl.play();
    }
}

import javafx.stage.*;
import javafx.scene.*;
import javafx.application.*;

public class CircleRunner extends Application {
    @Override
    public void start(Stage stage) {
        CircleMover cm = new CircleMover();

        Scene scene = new Scene(cm, 600, 600);

        stage.setScene(scene);

        stage.setTitle("Parapatetic Circles");
        stage.show();
    }
}