Windowed Systems Notes

--------------------
------08-24-17------
--------------------

seam graph:
	composed of nodes and subclasses of nodes
two distinct subclasses of node:
	-node -> parent -> REGION
		rectangular thing that supports being laid out and CSS styling
	-node -> parent -? GROUP
		can have any arbitrary transformation applied to it 
		good for neat custom graphics
		not easy to resize
lets say you have a window that you want to have resizable, that will move buttons and windows inside and stuff. 
	-good news: automatically recalculates size for you in most graphics kits
	-!!!!!!all homeworks will expect me to have a resizable interface!!!!!!
kits often include "v boxes" and "h boxes"--meaning, rows and columns that hold stuff
kits also have a grid type thing. it lays its area into rectilinear regions
	-elements can go into multiple cells
	-lets you control which areas should grow during resizing 
anchor points help you decide where a thing attatches and keeps its location somewhat static. depends how many achor points you add
can use grid or anchors for hw!!
checkmarks in JavaFx
	-some methods:
		getIsChecked()
		getIsCheckedProperty() -> allows binding. so if you bind the property to something else, you never have to connect them again, they just stay synched. 
	-more on binding: can also attatch events to properties this way
FXML
JavaFx applications don't need a main method. they do need the start method!

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}

lets add labels:

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Label bar = new Label("bar");
		root.add(bar,0,1);		//this one will go just below foo
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
mess with regions:

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Region r = new Region();	//supports no args on init
		root.add(r,1,1);	//below and to right of foo
		
		GridPane.setHgrow(r, Priority.ALWAYS);	//these static methods make sure that resizing
		GridPane.setVGrow(r, Priority.ALWAYS);	//works so that bar is always in bottom right
		
		Label bar = new Label("bar");
		root.add(12,2,2);
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
buttons:

	public void start(Stage primary){
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); 
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Region r = new Region();
		root.add(r,1,1);	//below and to right of foo
		
		GridPane.setHgrow(r, Priority.ALWAYS);
		GridPane.setVGrow(r, Priority.ALWAYS);
		
		Button butt = new Button("clicky");
		root.add(butt,2,2);
		butt.setOnAction(
			event -> { System.out.println("clickoo"); }	//when you click, terminal prints
		);												// you can also specify type of event
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
how to make an interface reusable:

	class BasicWidget extends GridPane {
		public BasicWidget(){
		
			Label foo = new Label("foo");
			add(foo, 0, 0);
			
			Region r = new Region();
			add(r,1,1);		//just add instead of root.add()
			
			GridPane.setHgrow(r, Priority.ALWAYS);
			GridPane.setVGrow(r, Priority.ALWAYS);
			
			Button butt = new Button("clicky");
			add(butt,2,2);
			butt.setOnAction(
				event -> { System.out.println("clickoo"); }
			);
		}
	}
	
	public void Start(Stage primary){
		primary.setTitle("window");
		BasicWidget bw = new BasicWidget(); //here's the replacement!
		primaryStage.setScene(new Scene(bw,400,400));	//bw instead of GridPane root as before
		primary.show();
	}
		
you can have multiple BasicWidgets if you want!

--------------------
------08-29-17------
--------------------

New hw to be assigned this Thrusday, and then due a week later.

Things we will cover today: checkbox, radio button, combobox
	-all these things inherit the clicked event
	-these things expose to us properties. Instead of listening for an action event, we want to use the info we would get from their interraction.
checkbox
	-we really just care about whether or not it's selected
	-three options: unchecked, checked, and " - ". 
		-some languages handle this by making it an enum type
		-JavaFx: two boolean properties: does this box allow indeterminence? Is it checked or unchecked?
		-in this class we are gonna ignore indeterminence. only checked and unchecked for now

checkbox example:

class ClassWidget extends GridPane {
	public ClassWidget(){
		CheckBox cb = new CheckBox("Check me!");
		add(cb, 0, 0);
		
		cb.setOnAction(
			(event) -> System.Out.Println("Hi"); //on check or uncheck, this goes to terminal
		);
	}
}
	
getting checkbox property:

class ClassWidget extends GridPane {
	public ClassWidget(){
		CheckBox cb = new CheckBox("Check me!");
		add(cb, 0, 0);
		
		cb.setOnAction(
			(event) -> System.Out.Println("Hi") //on check or uncheck, this goes to terminal
		);
			
		Button b = new Button("Print");
		add(b, 0, 50);		//it's okay to have a larger number for location than what's avaliable here, it works out
		b.setOnAction(
			(event) -> System.out.println(cb.selectedProperty().get())	//prints the state of the checkbox when you press the button
		);
	}
}
	
In most graphical kits, there is a concept of a control being enabled or disabled. Think of greyed out windows. 
In JavaFx, when you disable a control, the display will still be re-rendered (allowing resizing), it just can't generate events. 

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			cb.setOnAction(
				(event) -> System.Out.Println("Hi")
			);
				
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().set(true);	//note: DisableProperty is read/write, DisabledProperty is read-only
											//it's possible for them to be different. 
											//Disabled comes from its ancestors, Disable is specific to it. Shitty naming though lol
}}
	
disable events:

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
				
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().set(true);
			
			cb.setOnAction(
				(event) ->{
					if (cb.selectedProperty().get()){
						b.disableProperty().set(false);
					} else {
						b.disableProperty().set(true);
					}
				}
			);
}}
	
This setup has some annoying cross-coupling. There's a better way!

class ClassWidget extends GridPane {
public ClassWidget(){
	CheckBox cb = new CheckBox("Check me!");
	add(cb, 0, 0);
		
	Button b = new Button("Print");
	add(b, 0, 50);
	b.setOnAction(
		(event) -> System.out.println(cb.selectedProperty().get())
	);
	
	b.disableProperty().bind(Bindings.not(cb.selectedProperty()));	//system automatically connects the properties
	//Bindings class allows you to have a more specific binding. 
	//In this case it inverts, allowing b's property to be inverse to cb's property.
	//They start out in sync!!!! Binding guarentees that everything automatically updates form the start
}}

Radio buttons! Well, groups of radio buttons!
	-it's a lot like a checkbox, except that at most, only one in a given group can be checked at a time
	-some graphical kits allow you to have none selected, others will always have exactly one
	-JavaFx is fine with none selected. In this case, that is "null"

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ToggleGroup tga = new ToggleGroup();	//only one in a group can be selected
				
			RadioButton ra1 = new RadioButton("ra1");
			add(ra1, 0, 1);
			ra1.setToggleGroup(tga);	//ToggleGroup not exposed as a property, becuase that implies 
										//you'd want to change the grouping later, which is dumb
			
			RadioButton ra2 = new RadioButton("ra2");
			add(ra1, 0, 2);
			ra2.setToggleGroup(tga);
			
			RadioButton ra3 = new RadioButton("ra3");
			add(ra1, 1, 1);
			ra3.setToggleGroup(tga);
			
			tga.selectedToggleProperty().addListener(
				(observable, old_val, new_val) -> {
					System.out.println("changed");	//button selection prints this
				}
			);
				
}}

Above prints when there's a change! But what we would really like to know is which one is selected! So.

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ToggleGroup tga = new ToggleGroup();
				
			RadioButton ra1 = new RadioButton("ra1");
			add(ra1, 0, 1);
			ra1.setToggleGroup(tga);
			
			RadioButton ra2 = new RadioButton("ra2");
			add(ra1, 0, 2);
			ra2.setToggleGroup(tga);
			
			tga.selectedToggleProperty().addListener(
				(observable, old_val, new_val) -> {		//old_val and new_val are the actual RadioButtons
					if (new_val == ra1){
						System.out.println("ra1");
					} else if (new_val == ra2){
						System.out.println("ra2");
					}
				}
			);
				
}}

combo box!!! It's like a dropdown box, but a user can also type in their own new input.
	-used to be that comboboxes were just of strings
	-these days you can have a combobox of generics. they can be of anything... like.... aircrafts
	-this allows a custom displays. but it's yucky. so we aren't going to bother with it in class.
	-we're only gonna do string combo boxes for this class but maybe look into it for fun
	
class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ComboBox<String> combo = new ComboBox<String>();	//in Java you can leave out <Type> but it'll fuck you up reel good
			combo.getItems().addAll("One", "Two", "Three");		//by default, nothing is selected in combobox
			add(combo, 0, 3);									//but when you pick something you can't go back to nothing
			
			//what if one element has more than one setOnAction thing? The most recent one is the one that happens. Set replaces instead of adds!!!!
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(										//this is now dead code
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().bind(Bindings.not(cb.selectedProperty()));
			b.setOnAction(										//this replaces the last one
				(event) -> System.out.println(combo.getValue())
			);
			
}}

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ComboBox<String> combo = new ComboBox<String>();
			combo.getItems().addAll("One", "Two", "Three");
			add(combo, 0, 3);
			
			combo.valueProperty().addListener(
				(observable, old_val, new_val) -> {	//note: reselecting the same value doesn't 
					System.out.println(new_val);	//count as a change, so it won't fire off this event
				}
			);
			
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(										//this is now dead code
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().bind(Bindings.not(cb.selectedProperty()));
			b.setOnAction(										//this replaces the last one
				(event) -> System.out.println(combo.getValue())
			);
			
}}

--------------------
------08-31-17------
--------------------

Text widgets!

Graphics kits can support a TextLine (single line), TextBox (multiline), and some kind of Rich Text Control (styling included). RTC can be hella complicated, and varies between graphics kits, so we won't go too deep into it for this class. Some kits don't have separate modules for TextLine and TextBox (but not JavaFx since v.2). 

RW Properties in JavaFx are like "get__", "set__", and "__Property".

intro to TextField:

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);						//doesn't automatically reach best size
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())	//prints field's text to terminal
		);
		
		
	}
}

you can make pressing enter also always cause print.

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
			
		b.setDefaultButton(true);	//button turns blue to indicate it's default, means pressing enter causes this to go
	}
}

a different way to do it form inside textField

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		//Having both still only prints the first one (field.setOnAction(...) because
		//the defaultButton thing only goes into effect IFF no one else is using that enter key
	}
}

add TextArea

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		
		//weirdly, the textbox and textfield reach full size of window. 
		//they share a column, so the area made whole column got bigger, so the field grew.
		//if you expand window, they will keep growing until textfield finds it's 
		//default with.
	}
}

set expand size for TextArea

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);	//now that shit will grow forever. 
		setVgrow(area, Priority.ALWAYS);	//same for textfield because it's in that column
											//button won't grow by default
	}
}

Time for some Rich Text!!!!!!! in JavaFx, we use an HTML editor. Now, having the DefaultButton means enter will result in print. HTML doesn't use enter because the devs were like... this is ambiguous and we're scared so we won't do it.
Not every JavaFx distribution has HTML because life is unfair. You gotta install the preview of JDK 9.0. So if cross-platform development is important, maybe ignore the HTML becuase it's not everwhere. 

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);
		setVgrow(area, Priority.ALWAYS);
		
		HTML editor = new HTML();
		add(editor,0,4);
		//automatically has the styling buttons that most RTF editors have. 
	}
}

field prompt text

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		field.setPromptText("put words");
		//text does away when you select the field
		
		Button butt = new Button("Print");lr
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);
		setVgrow(area, Priority.ALWAYS);
		
		HTMLEditor editor = new HTMLEditor();
		add(editor,0,4);
	}
}

HOMEWORK! due on Sep 7th

	col1		col2		col3		col4
---------------------------------------------------------
|	o check1	o check2				[print but]		|
|										[submit but]	|
|	0 ra1		0 rb1									|
|	0 ra2		0 rb2									|
|	0 ra3		0 rb3									|
|														|
---------------------------------------------------------

when you hit submit, you append current status of each group/check/etc and stuff to message history.
when you hit print, print all of message history to terminal

--------------------
------09-05-17------
--------------------

Progress bar! Contains percentage done for a task. 
Sometimes it supports an indeterminate state (goes back and forth) for when task's progress is unknown. If it stops moving that means the task froze up, that means the event loop is no logner running, so the user knows the program fucked up.
main:
	set-up
	loop
		update state
		dispatch events
		//idle	<- olden days!!!! break up a big job into teeny tiny ones. good for progress bar, but awkward.
		redraw
	clean-up
	
Nowadays, just use threading. good: if thread fucks up, program still tuns. bad: time gets weird. if time isn't synched, and progress bar updates during the redraw, then you get issues and you can corrupt your state. This means, with another thread, you need to do extra wiring to make things talk in a safe way. We will talk about how to do this later.

For today we are just gonna hook the progress bar to a slider and worry about threads another day.

Sliders! Tracks current value, min/max, and type (int, double, etc.). Different kits do it differently. 

HELPFUL IMPORTS:
	javafx.scene.layout.*;
	javafx.scene.image.*;
	javafx.control.*;
	javafx.beans.*;

practice time! basic progress bar

class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0);		//when there's no configuration, it's just indeterminate state
		setHgrow(bar, Priotiy.ALWAYS);
		//the javafx fools have decided to treat progress bars like buttons, so they don't naturally change size. 
		//so you gotta manually set size to be huge for it to grow. but this can still break shit. thanks Oracle.
	}
}

class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator(); //it's the spinny wheel!
		add(ind,2,0);
		//indeterminate when value is less than zero
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
				//note: by default progress things go form 0.0 to 1.0 while 
				//slider goes from 0.0 to 100.0 so it obviously fills up progress fast.
		add(slider,0,1,2,1); //extra things are span so that it goes across columns
		
		bar.progressProperty().bind(slider.valueProperty());	//fills up
		int.progressProperty().bind(slider.valueProperty());	//becomes a checkbox basically
		
	}
}

time for container widgets and decorators. they contain other widgets and add extra bits. 
decorators (type of containers?):
	border widget: takes other component and draws a border around it
	scroll: lets you scroll through a widget and it stays small
container:
	GridPane (duh)
	
class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator();
		add(ind,2,0);
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
		add(slider,0,1,2,1);
		
		bar.progressProperty().bind(slider.valueProperty());
		int.progressProperty().bind(slider.valueProperty());
		
		Image img = new Image("file:trash.jpeg");
			//takes a URI instead of a filename because fuck you that's why
			//in something like NetBeans, image can be inside your jar file
		ImageView iview = new ImageView(img);
		add(iview,0,2,2,1);
		
	}
}

put iview in a scroll pane

class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator();
		add(ind,2,0);
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
		add(slider,0,1,2,1);
		
		bar.progressProperty().bind(slider.valueProperty());
		int.progressProperty().bind(slider.valueProperty());
		
		Image img = new Image("file:trash.jpeg");
		ImageView iview = new ImageView(img);
		
		ScrollPane scroller = new ScrollPane();
		add(scroller,0,1,1,2);
		scroller.setContent(iview);
		//note: scroller automatically dissapears when no longer needed
	}
}

Some graphical kits automatically add invisible scrollers around the thing, just set them visible. 
another scrolling example

class PanelWidget{//custom shit};

class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator();
		add(ind,2,0);
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
		add(slider,0,1,2,1);
		
		bar.progressProperty().bind(slider.valueProperty());
		int.progressProperty().bind(slider.valueProperty());
		
		Image img = new Image("file:trash.jpeg");
		ImageView iview = new ImageView(img);
		
		PanelWidget panel = new PanelWidget();
		
		ScrollPane scroller = new ScrollPane();
		add(scroller,0,1,1,2);
		scroller.setContent(panel);	//you can put scroll around any widget, not just an image
	}
}

time for tabs


class BarWidget extends GridPane{
	public BarWidget(){
		ProgressBar bar = new ProgressBar();
		add(bar,0,0); 
		setHgrow(bar, Priotiy.ALWAYS);
		
		ProgressIndicator ind = new ProgressIndicator();
		add(ind,2,0);
		
		Slider slider = new Slider(-0.3, 1.0, 1.0, 0.0);
		add(slider,0,1,2,1);
		
		bar.progressProperty().bind(slider.valueProperty());
		int.progressProperty().bind(slider.valueProperty());
		
		Image img = new Image("file:trash.jpeg");
		ImageView iview = new ImageView(img);
		
		PanelWidget panel = new PanelWidget();
		
		ScrollPane scroller = new ScrollPane();
		add(scroller,0,1,1,2);
		scroller.setContent(panel);
		
		TabPane pane = new TabPane();
		add(pane,0,3,2,1);
		
		Button b = new Button("Add tab");
		add(b,1,4);
		b.setOnAction(
			(event) -> {
				Tab t = new Tab();
				t.setText("New tab");
				t.setContent(new ImageView(img));	//imageview need to be remade because it can only show up once
				pane.getTabs().add(t);
			}
		);
		
		
	}
}

--------------------
------09-14-17------
--------------------

We are going to do an extra class on menus, may do classes on other toolkits. This is to not be too ahead of syllabus. Also attendance is gonna be a thing. 

Windows and dialog boxes

When you get multiple windows, how do you know when to close your application? Different toolkits deal with it differently. JavaSwing has a Window.OnClose() event. JavaFX and others by default end the application when all visible windows have closed. 

Modality--tells us the stacking order of a window. So if A can create B, A can OPTIONALLY e B's parent. With modality, as long as B is active, it blocks A and prevents interraction with A. A isn't necessarily disabled, it still renders and stuff, you just can't input anyhting. In JavaFX you need the parent relationship for this to work.

Consider a button in window A that shows window B. Normally, both windows are still inside a single event loop. 
event {
	callback {
		Window B = new BWin();
		B.BlockingShow(); 		//so if this is where program waits for input then
		print(B.property()); 	//to not break everything, it must spawn a new event loop
	}
}

Almost every windowing kit on the planet lets you do dialog boxes, and lets you skip all the extra steps of dealing with regular windows. 
Two types we'll cover: alerts and file choosers. Color pickers and prints are others that often exist. JavaFX's alert doesn't look like the system's alert. The file browser does though!

public class RunnerWindow extends Application{
	@Override
	public void start(Stage primaryStage){
		AlertWidget aw = new AlertWidget();
		aw.setAlightment(Pos.CENTER);
		
		primaeyStage.setTitle("inclass");
		primaryStage.setScnene(new Scene(aw,400,400);
		primaryStage.show();
	}
}

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.show();
			}
		)
		//this new window returns to the main event loop so you aren't blocking this AlertWidget with windowB
		//all windows must be closed for app to end
		
	}
	
	private Window getOwnerWindow(){ //you have to build this helper yourself :/
		Scene parentScene = this.getScene(); //is null when if it's never added to a node in the scene. 
		if (parentScene != null){
			return parentScene.getWindow();	//still nullable!! if scene hasn't been added to a window
		}
		return null;
	}
}

if you want to make your new stage modal with respect to the parent:

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				//modality can be to Application, Window, None. determines what gets blocked
				//for window modality you need to set the parent!
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		)
	}
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

more stuff with modality


public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		)
	}
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

basic alert

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		);
		
		Button alertB = new Button("Alert");
		add(alert,1,0);
		alertB.setOnAction(
			event -> {
				Alert a = new Alert(AlertType.CONFIRMATION);
				a.showAndWait();
				//automatically blocks other windows
			}
		);
	}
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

better alert

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button windowB = new Button("Window");
		add(windowB,0,0);
		WindowB.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		);
		
		Button alertB = new Button("Alert");
		add(alert,1,0);
		alertB.setOnAction(
			event -> {
				Alert a = new Alert(AlertType.CONFIRMATION, "Class is almost over!", ButtonType.OK, ButtonType.FINISH); 
				//Java's being like C#, doing the var args thing. Infinite button arguments allowed!
				Optional<ButtonType> result = a.showAndWait(); //this returns the selected button
				//Optional is a trivial object that allows result to be present or null. ButtonType is an enum and can't be null so you gotta do it
				//Optional is in Java.util
				if (result.isPresent() && result.get() == ButtonType.OK){
					System.out.println("Woo");
				}
			}
		);
	}
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

--------------------
------09-19-17------
--------------------

Menus

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button window = new Button("Window");
		add(window,0,0);
		Window.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		);
		
		Button alert = new Button("Alert");
		add(alert,1,0);
		alertB.setOnAction(
			event -> {
				Alert a = new Alert(AlertType.CONFIRMATION, "Class is almost over!", ButtonType.OK, ButtonType.FINISH); 
				//Java's being like C#, doing the var args thing. Infinite button arguments allowed!
				Optional<ButtonType> result = a.showAndWait(); //this returns the selected button
				//Optional is a trivial object that allows result to be present or null. ButtonType is an enum and can't be null so you gotta do it
				//Optional is in Java.util
				if (result.isPresent() && result.get() == ButtonType.OK){
					System.out.println("Woo");
				}
			}
		);
	}
	
	//here's the new thing
	Button save = new Button("Save");
	add(save,2,0);
	save.setOnAction(
		(event) -> {
			FileChooser chooser = new FileChooser();
			chooser.setTitkle("Choose a file");
					//there's also a way to do this where you only check for a single file
			List<File> fs = chooser.showOpenMultipleDialog(getOwnerWindow);
					//it can return null so you need to check for it
			if (fs != null){
				for (File f: fs){
					System.out.println(f.getName());
				}
			} else {
				System.out.println("Nothing was selected.");
			}
		}
	);
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

now file searching but with filters (so its like *.jpeg)

public class AlertWidget extends GridPane{
	public AlertWidget(){
	
		Button window = new Button("Window");
		add(window,0,0);
		Window.setOnAction(
			event -> {
				Stage s = new Stage();
				s.setTitle("new stage");
				s.initModality(Modality.WINDOW_MODAL);
				s.initStyle(StageStyle.Decorated); //or Undecorated for no header bit, so there's not even a close button
				s.setScene(new Scene(new PanelWidget()));
				s.initOwner(this.getOwnerWindow());
				s.showAndWait();
			}
		);
		
		Button alert = new Button("Alert");
		add(alert,1,0);
		alertB.setOnAction(
			event -> {
				Alert a = new Alert(AlertType.CONFIRMATION, "Class is almost over!", ButtonType.OK, ButtonType.FINISH); 
				//Java's being like C#, doing the var args thing. Infinite button arguments allowed!
				Optional<ButtonType> result = a.showAndWait(); //this returns the selected button
				//Optional is a trivial object that allows result to be present or null. ButtonType is an enum and can't be null so you gotta do it
				//Optional is in Java.util
				if (result.isPresent() && result.get() == ButtonType.OK){
					System.out.println("Woo");
				}
			}
		);
	}
	
	//here's the new thing
	Button save = new Button("Save");
	add(save,2,0);
	save.setOnAction(
		(event) -> {
			FileChooser chooser = new FileChooser();
			chooser.setTitle("Choose a file");
			
			chooser.getExtensionFilters().addAll(
				new ExtensionFilter("Source files","*.java", "*.py"),
				new ExtensionFilter("All Files","*");
			);
			//these extension filters show up in chooser and allow user to select between them
			
			List<File> fs = chooser.showOpenMultipleDialog(getOwnerWindow);
			
			if (fs != null){
				for (File f: fs){
					System.out.println(f.getName());
				}
			} else {
				System.out.println("Nothing was selected.");
			}
		}
	);
	
	private Window getOwnerWindow(){ 
		Scene parentScene = this.getScene();
		if (parentScene != null){
			return parentScene.getWindow();
		}
		return null;
	}
}

--------------------
------09-21-17------
--------------------

Menus! It's always pushed against the top of the container and is as wide as its parent. 
javafx.scene.control.MenuBar 	-> represents the entire bar
javafx.scene.control.Menu 		-> represents the items inside the menu. File, edit, etc.
javafx.scene.control.MenuItem	-> represents the submenus inside file, edit, etc

In other kits there is the concept of the abstract command. A command is a single point of implementation for some piece of application state. The idea is that if you have one [[ edit > cut ]] option, you have to store whatever's selected into the clipboard. Command allows you to package the action you do with the application state, plus other needed references, to do the thing. WPF and JavaSwing both have these things, and they're useful as hell.
Java FX doens't have it. You can kind of acheive the same result with action listeners. ActionListener<ActionEvent> { .... } won't be covered in class but it's an option for projects.

We're going to make a menu bar with one menu and one submenu. Going to start form the bottom up, just because it's easier. This time we're extending from VBox instead of GridPane, it's a layout container, too, just easier to get the menu where you want it. 

class MenuWidget extends VBox {
	class MenuWidget(){
		MenuBar bar = new MenuBar();
		Menu menu = new Menu("File");
		
		MenuItem open = new MenuItem("Open");
		MenuItem save = new MenuItem("Save");
		
		menu.getItems().addAll(open, save);
		
		this.getChildren().addAll(menu);
	}
}

At its current state, the menu bar is in the middle of the window! It's just a normal node, not meant to be attatched to the top by default. Gotta fix the location by setting the vertical grow priority.

class MenuWidget extends VBox {
	class MenuWidget(){
		MenuBar bar = new MenuBar();
		Menu menu = new Menu("File");
		
		MenuItem open = new MenuItem("Open");
		MenuItem save = new MenuItem("Save");
		
		menu.getItems().addAll(open, save);
		
		this.getChildren().addAll(menu);
		
		GridPane pane = new GridPane();
		this.getChildren().add(pane);
		VBox.setVgrow(panel, Priority.ALWAYS); //static method so can't use keyword this
		//now the menu's at the top!
	}
}

Remember that the gridpane takes its size from its largest child. At this time it has no children. A GridPane with growth priotity always has a size of zero in the top left corner, but it has an allocation of the entire white space of the window below the menu, and that's why the menu is pushed to the top. 

class MenuWidget extends VBox {
	class MenuWidget(){
		MenuBar bar = new MenuBar();
		Menu menu = new Menu("File");
		
		MenuItem open = new MenuItem("Open");
		MenuItem save = new MenuItem("Save");
		
		menu.getItems().addAll(open, save);
		
		this.getChildren().addAll(bar);
		
		GridPane pane = new GridPane();
		this.getChildren().add(pane);
		VBox.setVgrow(panel, Priority.ALWAYS); //static method so can't use keyword this
		//now the menu's at the top!
		
		pane.setStyle("-fx-grid-lines-visible: true; -fx-stroke: black;"); //adds gridlines that aren't debugger lines
		
		Button b = new Button("b");
		pane.add(b,0,0);
		
		//when you run itll show that the box only extends to the exact size of the button.
		
	}
}

adding actions to menu items.

Note: vboxes have it so that all children by default get the full horizontal allocation, which is good for menus! Thigns like the progress bar still won't grow because Oracle loves to make questionable choices.

class MenuWidget extends VBox {
	class MenuWidget(){
		MenuBar bar = new MenuBar();
		Menu menu = new Menu("File");
		
		MenuItem open = new MenuItem("Open");
		MenuItem save = new MenuItem("Save");
		
		GridPane pane = new GridPane();
		this.getChildren().add(pane);
		VBox.setVgrow(panel, Priority.ALWAYS);
		
		save.onAction(
			(event) -> {
				System.out.println("save clicked");
				
			}
		);
		
		SeperatorMenuItem sep = new SeperatorMenuItem();
		
		Menu recents = new Menu("Recent items");
		
		MenuItem lies = new MenuItem("Lies");
		MenuItems secrets = new MenuItem("Secrets");
		
		recents.getItems().addAll(lies, secrets);
		
		menu.getItems().addAll(open, save, sep, recents);
		
		bar.getMenus().addAll(menu);
		
		this.getChildren().addAll(bar);
		
	}
}

Now it's time to switch languages! GTK3 in Python! But in Python, Qt is better, but David Bolding has never used it so can't easily teach it to us on short notice. GTK3 is a little bit weird, it's very old and has been around for a long time. GIMP, that image program, had a graphical abstraction layer, and they branched it off into its own opensource toolkit. Most applications on Linux use it.

GTK was originally done in C. So they made the glib library, which is object oriented for C. It builds pseudo object oriented techniques using C macros on top of C structs. If you actually write a GTK program in C, it'll be super verbose. It's awkward and impractical. Because of this, GTK has branched out to other languages. They even made the language Vala, which looks like C#, but compiles into C, so there are some weird limitations (like no exceptions!)

So, python. You could use PYGTK, but its slow to update and only works up to v2. So for v3 onward, use Python G-object introspection. Introspection means, given an object you know nothing about, you can still load it up and use it. 

Is it reflection?? Kinda but no. See https://en.wikipedia.org/wiki/Type_introspection

With introspection, intellisense won't work, because it wants to see the whole library. That's because when you use introspection, the namespace is filled in at runtime, which just isn't compatible. 

Note: GTK appllications aren't the most Windows friendly. It's meant for Linux.

{

#! /usr/bin/python3

import gi
gi.require_version("Gtk","3.8");
from gi.repository import Gtk

win = Gtk.Window(title="Weakly-Typed window")

win.connect("delete-event". Gtk.main_quit)
	//this makes it to the exit button actually ends the program
	//.main_quit is a function that actually does the shut down action

win.show_all() //shows this window and any of its children


Gtk.main()

}

Weakly typing is similar to dynamic typing (where vars can change types). Weak typing means they don't have a well-defined type at runtime. A type is decided based on methods it has. So it doesn't enforce type restrictions, and python assumes you're following the rules. Doesn't this make it slower?

Python is functional, you can can carry functions around like variables and just give it to stuff. Good for this!

{

#! /usr/bin/python3

import gi
gi.require_version("Gtk","3.8");
from gi.repository import Gtk

win = Gtk.Window(title="Weakly-Typed window")

hbox = Gtk.Box()
win.add(hbox)

firstB = Gtk.Button.new_with_label(label="first!")
	//.new_with_label() is a factory method!!!!!!
hbox.pack_start(firstB, True, True, 3)
	//packs in from the beginning of the box. with an hbox the beginning is the left. it's like a load-in bay??
	//second is grow allocation
	//third if fill 
	//fourth is padding
	//so this appears in the very center of the window because its allocation lets it!!! 
	//there's padding around the left and right edes of the window outside the allocation

win.connect("delete-event". Gtk.main_quit)

win.show_all()


Gtk.main()

}

more on this

{

#! /usr/bin/python3

import gi
gi.require_version("Gtk","3.8");
from gi.repository import Gtk

win = Gtk.Window(title="Weakly-Typed window")

hbox = Gtk.Box()
win.add(hbox)

firstB = Gtk.Button.new_with_label(label="first!")
hbox.pack_start(firstB, False, True, 3)
	//grow is false, now button is on left side. stille xpands infinitely vertically, because it fills the row basically
	//if fill is false as well, it is the same as before. this is because the allocation doens't change, so fill won't either
	//if grow is true and fill is false, it hits its preferred horizontal size and lands right in the middle of the window.

win.connect("delete-event". Gtk.main_quit)

win.show_all()


Gtk.main()

}

There's Glade, a graphical Gtk builder. Niiice.

{

#! /usr/bin/python3

import gi
gi.require_version("Gtk","3.8");
from gi.repository import Gtk

win = Gtk.Window(title="Weakly-Typed window")

hbox = Gtk.Box()
win.add(hbox)

firstB = Gtk.Button.new_with_label(label="first!")
hbox.pack_start(firstB, False, True, 3)

secondB = Gtk.Button.new_with_mnemonic(label="second")
secondB.connect("clicked", lambda widget: print("I was clicked"))
	//^ this is a lambda expression!!!! 
	//widget is the argumement name, thing after the colon is what to do next
hbox.packstart(secondB,True,True,3)

win.connect("delete-event". Gtk.main_quit)

win.show_all()

class ExWindow(Gtk.Window):
	def __init__(self, title):
		super().__init__(title=title)
		
		hbox = Gtk.Box()
		butt = Gtk.Button.new_with_mnenomic(labek="click me")
		butt.connect("clicked",self.clicked)
		hbox.pack_start(butt, true,true,10)
		self.add(hbox)
		
	def clicked(self,source):
		print("clicked")
		
e.exWindow(title="hot potato")
e.show_all()

Gtk.main()

}

In python, self is basically this. def __init(self) is a constructor. You have to explicitly call your superclass's constructor. 
self.clicked in butt.connect("clicked",self.clicked) is actually a bound method. This means the e object gets a clicked method that has one argument, and just calls that. so what's happening is this: e.clicked = lambda source: ExWindow.clicked(e, source)
Basically, it's a weird method that, behind the scenes, magics its way into working. Magic is the worst. 

