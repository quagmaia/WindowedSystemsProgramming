Windowed Systems Notes

--------------------
------08-24-17------
--------------------

seam graph:
	composed of nodes and subclasses of nodes
two distinct subclasses of node:
	-node -> parent -> REGION
		rectangular thing that supports being laid out and CSS styling
	-node -> parent -? GROUP
		can have any arbitrary transformation applied to it 
		good for neat custom graphics
		not easy to resize
lets say you have a window that you want to have resizable, that will move buttons and windows inside and stuff. 
	-good news: automatically recalculates size for you in most graphics kits
	-!!!!!!all homeworks will expect me to have a resizable interface!!!!!!
kits often include "v boxes" and "h boxes"--meaning, rows and columns that hold stuff
kits also have a grid type thing. it lays its area into rectilinear regions
	-elements can go into multiple cells
	-lets you control which areas should grow during resizing 
anchor points help you decide where a thing attatches and keeps its location somewhat static. depends how many achor points you add
can use grid or anchors for hw!!
checkmarks in JavaFx
	-some methods:
		getIsChecked()
		getIsCheckedProperty() -> allows binding. so if you bind the property to something else, you never have to connect them again, they just stay synched. 
	-more on binding: can also attatch events to properties this way
FXML
JavaFx applications don't need a main method. they do need the start method!

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}

lets add labels:

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Label bar = new Label("bar");
		root.add(bar,0,1);		//this one will go just below foo
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
mess with regions:

	public void start(Stage primary){ //stage is the window your application is in
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); //this is a widget, at least for JavaFx. not for Swing
										//widgets can lay out children and is a graphical element
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Region r = new Region();	//supports no args on init
		root.add(r,1,1);	//below and to right of foo
		
		GridPane.setHgrow(r, Priority.ALWAYS);	//these static methods make sure that resizing
		GridPane.setVGrow(r, Priority.ALWAYS);	//works so that bar is always in bottom right
		
		Label bar = new Label("bar");
		root.add(12,2,2);
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
buttons:

	public void start(Stage primary){
		primary.setTitle("Window");
		
		GridPane root = new GridPane(); 
										
		Label foo = new Label("foo");
		root.add(foo, 0, 0);	//0,0 args put label in top right of grid
		
		Region r = new Region();
		root.add(r,1,1);	//below and to right of foo
		
		GridPane.setHgrow(r, Priority.ALWAYS);
		GridPane.setVGrow(r, Priority.ALWAYS);
		
		Button butt = new Button("clicky");
		root.add(butt,2,2);
		butt.setOnAction(
			event -> { System.out.println("clickoo"); }	//when you click, terminal prints
		);												// you can also specify type of event
	
		primary.setScene(new Scene(root, 400, 400,)); 
		primary.show();	//this actually displays the window
	}
	
how to make an interface reusable:

	class BasicWidget extends GridPane {
		public BasicWidget(){
		
			Label foo = new Label("foo");
			root.add(foo, 0, 0);
			
			Region r = new Region();
			add(r,1,1);		//just add instead of root.add()
			
			GridPane.setHgrow(r, Priority.ALWAYS);
			GridPane.setVGrow(r, Priority.ALWAYS);
			
			Button butt = new Button("clicky");
			add(butt,2,2);
			butt.setOnAction(
				event -> { System.out.println("clickoo"); }
			);
		}
	}
	
	public void Start(Stage primary){
		primary.setTitle("window");
		BasicWidget bw = new BasicWidget(); //here's the replacement!
		primaryStage.setScene(new Scene(bw,400,400));	//bw instead of GridPane root as before
		primary.show();
	}
		
you can have multiple BasicWidgets if you want!

--------------------
------08-29-17------
--------------------

New hw to be assigned this Thrusday, and then due a week later.

Things we will cover today: checkbox, radio button, combobox
	-all these things inherit the clicked event
	-these things expose to us properties. Instead of listening for an action event, we want to use the info we would get from their interraction.
checkbox
	-we really just care about whether or not it's selected
	-three options: unchecked, checked, and " - ". 
		-some languages handle this by making it an enum type
		-JavaFx: two boolean properties: does this box allow indeterminence? Is it checked or unchecked?
		-in this class we are gonna ignore indeterminence. only checked and unchecked for now

checkbox example:

class ClassWidget extends GridPane {
	public ClassWidget(){
		CheckBox cb = new CheckBox("Check me!");
		add(cb, 0, 0);
		
		cb.setOnAction(
			(event) -> System.Out.Println("Hi"); //on check or uncheck, this goes to terminal
		);
	}
}
	
getting checkbox property:

class ClassWidget extends GridPane {
	public ClassWidget(){
		CheckBox cb = new CheckBox("Check me!");
		add(cb, 0, 0);
		
		cb.setOnAction(
			(event) -> System.Out.Println("Hi") //on check or uncheck, this goes to terminal
		);
			
		Button b = new Button("Print");
		add(b, 0, 50);		//it's okay to have a larger number for location than what's avaliable here, it works out
		b.setOnAction(
			(event) -> System.out.println(cb.selectedProperty().get())	//prints the state of the checkbox when you press the button
		);
	}
}
	
In most graphical kits, there is a concept of a control being enabled or disabled. Think of greyed out windows. 
In JavaFx, when you disable a control, the display will still be re-rendered (allowing resizing), it just can't generate events. 

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			cb.setOnAction(
				(event) -> System.Out.Println("Hi")
			);
				
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().set(true);	//note: DisableProperty is read/write, DisabledProperty is read-only
											//it's possible for them to be different. 
											//Disabled comes from its ancestors, Disable is specific to it. Shitty naming though lol
}}
	
disable events:

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
				
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().set(true);
			
			cb.setOnAction(
				(event) ->{
					if (cb.selectedProperty().get()){
						b.disableProperty().set(false);
					} else {
						b.disableProperty().set(true);
					}
				}
			);
}}
	
This setup has some annoying cross-coupling. There's a better way!

class ClassWidget extends GridPane {
public ClassWidget(){
	CheckBox cb = new CheckBox("Check me!");
	add(cb, 0, 0);
		
	Button b = new Button("Print");
	add(b, 0, 50);
	b.setOnAction(
		(event) -> System.out.println(cb.selectedProperty().get())
	);
	
	b.disableProperty().bind(Bindings.not(cb.selectedProperty()));	//system automatically connects the properties
	//Bindings class allows you to have a more specific binding. 
	//In this case it inverts, allowing b's property to be inverse to cb's property.
	//They start out in sync!!!! Binding guarentees that everything automatically updates form the start
}}

Radio buttons! Well, groups of radio buttons!
	-it's a lot like a checkbox, except that at most, only one in a given group can be checked at a time
	-some graphical kits allow you to have none selected, others will always have exactly one
	-JavaFx is fine with none selected. In this case, that is "null"

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ToggleGroup tga = new ToggleGroup();	//only one in a group can be selected
				
			RadioButton ra1 = new RadioButton("ra1");
			add(ra1, 0, 1);
			ra1.setToggleGroup(tga);	//ToggleGroup not exposed as a property, becuase that implies 
										//you'd want to change the grouping later, which is dumb
			
			RadioButton ra2 = new RadioButton("ra2");
			add(ra1, 0, 2);
			ra2.setToggleGroup(tga);
			
			RadioButton ra3 = new RadioButton("ra3");
			add(ra1, 1, 1);
			ra3.setToggleGroup(tga);
			
			tga.selectedToggleProperty().addListener(
				(observable, old_val, new_val) -> {
					System.out.println("changed");	//button selection prints this
				}
			);
				
}}

Above prints when there's a change! But what we would really like to know is which one is selected! So.

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ToggleGroup tga = new ToggleGroup();
				
			RadioButton ra1 = new RadioButton("ra1");
			add(ra1, 0, 1);
			ra1.setToggleGroup(tga);
			
			RadioButton ra2 = new RadioButton("ra2");
			add(ra1, 0, 2);
			ra2.setToggleGroup(tga);
			
			tga.selectedToggleProperty().addListener(
				(observable, old_val, new_val) -> {		//old_val and new_val are the actual RadioButtons
					if (new_val == ra1){
						System.out.println("ra1");
					} else if (new_val == ra2){
						System.out.println("ra2");
					}
				}
			);
				
}}

combo box!!! It's like a dropdown box, but a user can also type in their own new input.
	-used to be that comboboxes were just of strings
	-these days you can have a combobox of generics. they can be of anything... like.... aircrafts
	-this allows a custom displays. but it's yucky. so we aren't going to bother with it in class.
	-we're only gonna do string combo boxes for this class but maybe look into it for fun
	
class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ComboBox<String> combo = new ComboBox<String>();	//in Java you can leave out <Type> but it'll fuck you up reel good
			combo.getItems().addAll("One", "Two", "Three");		//by default, nothing is selected in combobox
			add(combo, 0, 3);									//but when you pick something you can't go back to nothing
			
			//what if one element has more than one setOnAction thing? The most recent one is the one that happens. Set replaces instead of adds!!!!
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(										//this is now dead code
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().bind(Bindings.not(cb.selectedProperty()));
			b.setOnAction(										//this replaces the last one
				(event) -> System.out.println(combo.getValue())
			);
			
}}

class ClassWidget extends GridPane {
		public ClassWidget(){
			CheckBox cb = new CheckBox("Check me!");
			add(cb, 0, 0);
			
			ComboBox<String> combo = new ComboBox<String>();
			combo.getItems().addAll("One", "Two", "Three");
			add(combo, 0, 3);
			
			combo.valueProperty().addListener(
				(observable, old_val, new_val) -> {	//note: reselecting the same value doesn't 
					System.out.println(new_val);	//count as a change, so it won't fire off this event
				}
			);
			
			Button b = new Button("Print");
			add(b, 0, 50);
			b.setOnAction(										//this is now dead code
				(event) -> System.out.println(cb.selectedProperty().get())
			);
			
			b.disableProperty().bind(Bindings.not(cb.selectedProperty()));
			b.setOnAction(										//this replaces the last one
				(event) -> System.out.println(combo.getValue())
			);
			
}}

--------------------
------08-31-17------
--------------------

Text widgets!

Graphics kits can support a TextLine (single line), TextBox (multiline), and some kind of Rich Text Control (styling included). RTC can be hella complicated, and varies between graphics kits, so we won't go too deep into it for this class. Some kits don't have separate modules for TextLine and TextBox (but not JavaFx since v.2). 

RW Properties in JavaFx are like "get__", "set__", and "__Property".

intro to TextField:

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);						//doesn't automatically reach best size
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())	//prints field's text to terminal
		);
		
		
	}
}

you can make pressing enter also always cause print.

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
			
		b.setDefaultButton(true);	//button turns blue to indicate it's default, means pressing enter causes this to go
	}
}

a different way to do it form inside textField

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		//Having both still only prints the first one (field.setOnAction(...) because
		//the defaultButton thing only goes into effect IFF no one else is using that enter key
	}
}

add TextArea

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		
		//weirdly, the textbox and textfield reach full size of window. 
		//they share a column, so the area made whole column got bigger, so the field grew.
		//if you expand window, they will keep growing until textfield finds it's 
		//default with.
	}
}

set expand size for TextArea

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);	//now that shit will grow forever. 
		setVgrow(area, Priority.ALWAYS);	//same for textfield because it's in that column
											//button won't grow by default
	}
}

Time for some Rich Text!!!!!!! in JavaFx, we use an HTML editor. Now, having the DefaultButton means enter will result in print. HTML doesn't use enter because the devs were like... this is ambiguous and we're scared so we won't do it.
Not every JavaFx distribution has HTML because life is unfair. You gotta install the preview of JDK 9.0. So if cross-platform development is important, maybe ignore the HTML becuase it's not everwhere. 

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		Button butt = new Button("Print");
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);
		setVgrow(area, Priority.ALWAYS);
		
		HTML editor = new HTML();
		add(editor,0,4);
		//automatically has the styling buttons that most RTF editors have. 
	}
}

field prompt text

class ClassWidget extends GridPane {
	public ClassWidget() {
		TextField field = new TextField();
		add(field,0,0);
		
		field.setPromptText("put words");
		//text does away when you select the field
		
		Button butt = new Button("Print");lr
		add(button,0,1);
		butt.setOnAction(
			(event) -> System.out.println(field.getText())
		);
		
		field.setOnAction(
			(event) -> System.out.println("Text: " + field.getText())
		);
		b.setDefaultButton(true);
		
		TextArea area = new TextArea();
		add(area,0,2);
		setHgrow(area, Priority.ALWAYS);
		setVgrow(area, Priority.ALWAYS);
		
		HTMLEditor editor = new HTMLEditor();
		add(editor,0,4);
	}
}

HOMEWORK! due on Sep 7th

	col1		col2		col3		col4
-----------------------------------------------------
|	o check1	o check2				[print but]		|
|										[submit but]	|
|	0 ra1		0 rb1									|
|	0 ra2		0 rb2									|
|	0 ra3		0 rb3									|
|														|
-----------------------------------------------------

when you hit submit, you append current status of each group/check/etc and stuff to message history.
when you hit print, print all of message history to terminal